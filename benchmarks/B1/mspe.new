Trying to load file: mspe.koat

Initial Control flow graph problem:
  Start location: start
      0: start -> m1 : [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A ], cost: 1
      1: m1 -> m1 : C'=free_1, F'=free, [ B>=1 && D>=0 && A>=1+E && 1+B>=free && 1+C>=free_1 && free_1>=1+C && 1+F>=free && free>=1+F ], cost: 1
      2: m1 -> m1 : A'=free_3, F'=free_2, [ B>=1 && D>=0 && B>=F && 1+E>=free_3 && C>=1+B && 1+F>=free_2 && free_2>=1+F && 1+A>=free_3 && free_3>=1+A ], cost: 1
      3: m1 -> m1 : C'=free_5, F'=free_4, [ B>=1 && D>=0 && B>=F && 1+B>=free_5 && E>=A && 1+F>=free_4 && free_4>=1+F && 1+C>=free_5 && free_5>=1+C ], cost: 1
      4: m1 -> m1 : A'=free_7, F'=free_6, [ B>=1 && D>=0 && B>=F && B>=C && 1+E>=free_7 && 1+A>=free_7 && free_7>=1+A && 1+F>=free_6 && free_6>=1+F ], cost: 1


Simplified the transitions:
  Start location: start
      0: start -> m1 : [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A ], cost: 1
      1: m1 -> m1 : C'=1+C, F'=1+F, [ B>=1 && D>=0 && A>=1+E && 1+B>=1+F ], cost: 1
      2: m1 -> m1 : A'=1+A, F'=1+F, [ B>=1 && D>=0 && B>=F && 1+E>=1+A && C>=1+B ], cost: 1
      3: m1 -> m1 : C'=1+C, F'=1+F, [ B>=1 && D>=0 && B>=F && 1+B>=1+C && E>=A ], cost: 1
      4: m1 -> m1 : A'=1+A, F'=1+F, [ B>=1 && D>=0 && B>=F && B>=C && 1+E>=1+A ], cost: 1


Try instantiation
  Start location: start
      0: start -> m1 : [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A ], cost: 1
      5: m1 -> m1 : A'=1+E, F'=1+F+E-A, [ B>=F+E-A && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1+E-A
      6: m1 -> m1 : A'=1-F+B+A, F'=1+B, [ E>=-F+B+A && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1-F+B
      7: m1 -> m1 : C'=1-F+B+C, F'=1+B, [ 0>=-F+C && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1-F+B
      8: m1 -> m1 : C'=1+B, F'=1+F+B-C, [ 0>=F-C && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1+B-C
      9: m1 -> m1 : A'=1-F+B+A, F'=1+B, [ E>=-F+B+A && C>=1+B && B>=1 && D>=0 && B>=F && E>=A ], cost: 1-F+B
     10: m1 -> m1 : A'=1+E, F'=1+F+E-A, [ B>=F+E-A && C>=1+B && B>=1 && D>=0 && B>=F && E>=A ], cost: 1+E-A
     11: m1 -> m1 : C'=1-F+B+C, F'=1+B, [ A>=1+E && B>=F && B>=1 && D>=0 ], cost: 1-F+B

Eliminating 7 self-loops for location m1
  Removing the self-loops: 5 6 7 8 9 10 11.
Adding an epsilon transition (to model nonexecution of the loops): 19.

Removed all Self-loops using metering functions (where possible):
  Start location: start
      0: start -> m1 : [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A ], cost: 1
     12: m1 -> [2] : A'=1+E, F'=1+F+E-A, [ B>=F+E-A && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1+E-A
     13: m1 -> [2] : A'=1-F+B+A, F'=1+B, [ E>=-F+B+A && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1-F+B
     14: m1 -> [2] : C'=1-F+B+C, F'=1+B, [ 0>=-F+C && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1-F+B
     15: m1 -> [2] : C'=1+B, F'=1+F+B-C, [ 0>=F-C && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 1+B-C
     16: m1 -> [2] : A'=1-F+B+A, F'=1+B, [ E>=-F+B+A && C>=1+B && B>=1 && D>=0 && B>=F && E>=A ], cost: 1-F+B
     17: m1 -> [2] : A'=1+E, F'=1+F+E-A, [ B>=F+E-A && C>=1+B && B>=1 && D>=0 && B>=F && E>=A ], cost: 1+E-A
     18: m1 -> [2] : C'=1-F+B+C, F'=1+B, [ A>=1+E && B>=F && B>=1 && D>=0 ], cost: 1-F+B
     19: m1 -> [2] : [], cost: 0


Applied chaining over branches and pruning:
  Start location: start
     20: start -> [2] : A'=1+E, F'=1+F+E-A, [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && B>=F+E-A && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 2+E-A
     21: start -> [2] : C'=1+B, F'=1+F+B-C, [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && 0>=F-C && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 2+B-C


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start
     20: start -> [2] : A'=1+E, F'=1+F+E-A, [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && B>=F+E-A && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 2+E-A
     21: start -> [2] : C'=1+B, F'=1+F+B-C, [ A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && 0>=F-C && E>=A && B>=1 && D>=0 && B>=F && B>=C ], cost: 2+B-C


Computing complexity for remaining 2 transitions.

  Found configuration with infinitely models for cost: 2+E-A
  and guard: A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && B>=F+E-A && E>=A && B>=1 && D>=0 && B>=F && B>=C:
  F: Both, E: Both, B: Const, A: Const, C: Const, D: Pos

Found new complexity const, because: Found infinity configuration.

  Found configuration with infinitely models for cost: 2+B-C
  and guard: A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && 0>=F-C && E>=A && B>=1 && D>=0 && B>=F && B>=C:
  F: Both, E: Both, B: Const, A: Const, C: Const, D: Pos


The final runtime is determined by this resulting transition:
  Final Guard: A>=0 && 2+B+A>=2*C && B>=1+A && 2*C>=B+A && D>=0 && 1+E==C && F==A && B>=F+E-A && E>=A && B>=1 && D>=0 && B>=F && B>=C
  Final Cost:  1+E

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
