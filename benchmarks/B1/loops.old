Trying to load file: loops.koat

Initial Control flow graph problem:
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsentryin : [], cost: 1
      1: evalloopsentryin -> evalloopsbb6in : [ A>=0 ], cost: 1
      2: evalloopsentryin -> evalloopsreturnin : [ 0>=1+A ], cost: 1
      4: evalloopsbb6in -> evalloopsreturnin : [ 0>=1+A ], cost: 1
      3: evalloopsbb6in -> evalloopsbb1in : [ A>=0 ], cost: 1
     11: evalloopsreturnin -> evalloopsstop : [], cost: 1
      5: evalloopsbb1in -> evalloopsbb4in : B'=1, [ A>=2 ], cost: 1
      6: evalloopsbb1in -> evalloopsbb5in : B'=free, [ 1>=A ], cost: 1
      8: evalloopsbb4in -> evalloopsbb5in : [ B>=A ], cost: 1
      7: evalloopsbb4in -> evalloopsbb3in : [ A>=1+B ], cost: 1
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1
      9: evalloopsbb3in -> evalloopsbb4in : B'=2*B, [], cost: 1


Simplified the transitions:
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsentryin : [], cost: 1
      1: evalloopsentryin -> evalloopsbb6in : [ A>=0 ], cost: 1
      3: evalloopsbb6in -> evalloopsbb1in : [ A>=0 ], cost: 1
      5: evalloopsbb1in -> evalloopsbb4in : B'=1, [ A>=2 ], cost: 1
      6: evalloopsbb1in -> evalloopsbb5in : B'=free, [ 1>=A ], cost: 1
      8: evalloopsbb4in -> evalloopsbb5in : [ B>=A ], cost: 1
      7: evalloopsbb4in -> evalloopsbb3in : [ A>=1+B ], cost: 1
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1
      9: evalloopsbb3in -> evalloopsbb4in : B'=2*B, [], cost: 1


Eliminated locations (linear):
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
      3: evalloopsbb6in -> evalloopsbb1in : [ A>=0 ], cost: 1
      5: evalloopsbb1in -> evalloopsbb4in : B'=1, [ A>=2 ], cost: 1
      6: evalloopsbb1in -> evalloopsbb5in : B'=free, [ 1>=A ], cost: 1
      7: evalloopsbb4in -> evalloopsbb4in : B'=2*B, [ A>=1+B ], cost: 2
      8: evalloopsbb4in -> evalloopsbb5in : [ B>=A ], cost: 1
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1

Eliminating 1 self-loops for location evalloopsbb4in
  Removing the self-loops: 7.

Accelerated all simple loops using metering functions (where possible):
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
      3: evalloopsbb6in -> evalloopsbb1in : [ A>=0 ], cost: 1
      5: evalloopsbb1in -> evalloopsbb4in : B'=1, [ A>=2 ], cost: 1
      6: evalloopsbb1in -> evalloopsbb5in : B'=free, [ 1>=A ], cost: 1
     12: evalloopsbb4in -> evalloopsbb4in : B'=2*B, [ A>=1+B ], cost: 2
      8: evalloopsbb4in -> evalloopsbb5in : [ B>=A ], cost: 1
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1


Chained simpled loops:
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
      3: evalloopsbb6in -> evalloopsbb1in : [ A>=0 ], cost: 1
      5: evalloopsbb1in -> evalloopsbb4in : B'=1, [ A>=2 ], cost: 1
     13: evalloopsbb1in -> evalloopsbb4in : B'=2, [ A>=2 && A>=2 ], cost: 3
      6: evalloopsbb1in -> evalloopsbb5in : B'=free, [ 1>=A ], cost: 1
      8: evalloopsbb4in -> evalloopsbb5in : [ B>=A ], cost: 1
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1


Eliminated locations (branches):
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
     14: evalloopsbb6in -> evalloopsbb4in : B'=1, [ A>=0 && A>=2 ], cost: 2
     15: evalloopsbb6in -> evalloopsbb4in : B'=2, [ A>=0 && A>=2 && A>=2 ], cost: 4
     16: evalloopsbb6in -> evalloopsbb5in : B'=free, [ A>=0 && 1>=A ], cost: 2
      8: evalloopsbb4in -> evalloopsbb5in : [ B>=A ], cost: 1
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1


Eliminated locations (branches):
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
     16: evalloopsbb6in -> evalloopsbb5in : B'=free, [ A>=0 && 1>=A ], cost: 2
     17: evalloopsbb6in -> evalloopsbb5in : B'=2, [ A>=0 && A>=2 && A>=2 && 2>=A ], cost: 5
     10: evalloopsbb5in -> evalloopsbb6in : A'=-1+A, [], cost: 1


Eliminated locations (branches):
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
     18: evalloopsbb6in -> evalloopsbb6in : A'=-1+A, B'=free, [ A>=0 && 1>=A ], cost: 3
     19: evalloopsbb6in -> evalloopsbb6in : A'=-1+A, B'=2, [ A>=0 && A>=2 && A>=2 && 2>=A ], cost: 6

Eliminating 2 self-loops for location evalloopsbb6in
  Self-Loop 18 has the metering function: 1+A, resulting in the new transition 20.
  Self-Loop 19 has the metering function: -1+A, resulting in the new transition 21.
  Found this metering function when nesting loops: meter,
  Found this metering function when nesting loops: meter_1,
  Removing the self-loops: 18 19.

Accelerated all simple loops using metering functions (where possible):
  Start location: evalloopsstart
      0: evalloopsstart -> evalloopsbb6in : [ A>=0 ], cost: 2
     20: evalloopsbb6in -> evalloopsbb6in : A'=-1, B'=free, [ A>=0 && 1>=A ], cost: 3+3*A
     21: evalloopsbb6in -> evalloopsbb6in : A'=1, B'=2, [ 2-A==0 ], cost: -6+6*A


Chained simpled loops:
  Start location: evalloopsstart
     22: evalloopsstart -> evalloopsbb6in : A'=-1, B'=free, [ A>=0 && A>=0 && 1>=A ], cost: 5+3*A
     23: evalloopsstart -> evalloopsbb6in : A'=1, B'=2, [ A>=0 && 2-A==0 ], cost: -4+6*A


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: evalloopsstart
     22: evalloopsstart -> evalloopsbb6in : A'=-1, B'=free, [ A>=0 && A>=0 && 1>=A ], cost: 5+3*A
     23: evalloopsstart -> evalloopsbb6in : A'=1, B'=2, [ A>=0 && 2-A==0 ], cost: -4+6*A


Computing complexity for remaining 2 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
