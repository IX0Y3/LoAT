Trying to load file: heidy7.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f1 : A'=0, [], cost: 1
      1: f1 -> f1 : B'=-1+B, C'=free, [ B>=1 && free>=1 ], cost: 1
      2: f1 -> f1 : B'=-2+B, C'=free_1, [ B>=1 && 0>=free_1 ], cost: 1
      3: f1 -> f4 : C'=free_2, [ 0>=B ], cost: 1
      4: f4 -> f4 : A'=1, C'=free_3, [ C>=1 ], cost: 1
      5: f4 -> f4 : A'=2, C'=free_4, [ 0>=C ], cost: 1


Try instantiation
  Start location: f0
      0: f0 -> f1 : A'=0, [], cost: 1
      6: f1 -> f1 : B'=B-2*meter, C'=free_1, [ B-2*meter>=-1 && 2*meter==1+B && B>=1 ], cost: meter
      7: f1 -> f1 : B'=0, C'=free, [ B>=1 ], cost: B
      3: f1 -> f4 : C'=free_2, [ 0>=B ], cost: 1
      4: f4 -> f4 : A'=1, C'=free_3, [ C>=1 ], cost: 1
      5: f4 -> f4 : A'=2, C'=free_4, [ 0>=C ], cost: 1

Eliminating 2 self-loops for location f1
  Removing the self-loops: 6 7.
Adding an epsilon transition (to model nonexecution of the loops): 10.

Try instantiation
  Start location: f0
      0: f0 -> f1 : A'=0, [], cost: 1
      8: f1 -> [3] : B'=B-2*meter, C'=free_1, [ 2*meter==1+B && B>=1 ], cost: meter
      9: f1 -> [3] : B'=0, C'=free, [ B>=1 ], cost: B
     10: f1 -> [3] : [], cost: 0
     11: f4 -> f4 : [ 0>=C ], cost: INF
     12: f4 -> f4 : [ C>=1 ], cost: INF
      3: [3] -> f4 : C'=free_2, [ 0>=B ], cost: 1

Eliminating 2 self-loops for location f4
  Removing the self-loops: 11 12.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f1 : A'=0, [], cost: 1
      8: f1 -> [3] : B'=B-2*meter, C'=free_1, [ 2*meter==1+B && B>=1 ], cost: meter
      9: f1 -> [3] : B'=0, C'=free, [ B>=1 ], cost: B
     10: f1 -> [3] : [], cost: 0
     13: f4 -> [4] : [ 0>=C ], cost: INF
     14: f4 -> [4] : [ C>=1 ], cost: INF
      3: [3] -> f4 : C'=free_2, [ 0>=B ], cost: 1


Applied chaining over branches and pruning:
  Start location: f0
     15: f0 -> [3] : A'=0, B'=B-2*meter, C'=free_1, [ 2*meter==1+B && B>=1 ], cost: 1+meter
     16: f0 -> [3] : A'=0, B'=0, C'=free, [ B>=1 ], cost: 1+B
     17: f0 -> [3] : A'=0, [], cost: 1
     18: [3] -> [4] : C'=free_2, [ 0>=B && 0>=free_2 ], cost: INF
     19: [3] -> [4] : C'=free_2, [ 0>=B && free_2>=1 ], cost: INF


Applied chaining over branches and pruning:
  Start location: f0
     20: f0 -> [4] : A'=0, B'=B-2*meter, C'=free_2, [ 2*meter==1+B && B>=1 && 0>=B-2*meter && 0>=free_2 ], cost: INF
     21: f0 -> [4] : A'=0, B'=B-2*meter, C'=free_2, [ 2*meter==1+B && B>=1 && 0>=B-2*meter && free_2>=1 ], cost: INF
     22: f0 -> [4] : A'=0, B'=0, C'=free_2, [ B>=1 && 0>=0 && 0>=free_2 ], cost: INF
     23: f0 -> [4] : A'=0, B'=0, C'=free_2, [ B>=1 && 0>=0 && free_2>=1 ], cost: INF
     25: f0 -> [4] : A'=0, C'=free_2, [ 0>=B && free_2>=1 ], cost: INF


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     20: f0 -> [4] : A'=0, B'=B-2*meter, C'=free_2, [ 2*meter==1+B && B>=1 && 0>=B-2*meter && 0>=free_2 ], cost: INF
     21: f0 -> [4] : A'=0, B'=B-2*meter, C'=free_2, [ 2*meter==1+B && B>=1 && 0>=B-2*meter && free_2>=1 ], cost: INF
     22: f0 -> [4] : A'=0, B'=0, C'=free_2, [ B>=1 && 0>=0 && 0>=free_2 ], cost: INF
     23: f0 -> [4] : A'=0, B'=0, C'=free_2, [ B>=1 && 0>=0 && free_2>=1 ], cost: INF
     25: f0 -> [4] : A'=0, C'=free_2, [ 0>=B && free_2>=1 ], cost: INF


Computing complexity for remaining 5 transitions.

Found new complexity INF, because: INF sat.


The final runtime is determined by this resulting transition:
  Final Guard: 2*meter==1+B && B>=1 && 0>=B-2*meter && 0>=free_2
  Final Cost:  INF

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: INF
  Complexity value: INF

WORST_CASE(INF,?)
