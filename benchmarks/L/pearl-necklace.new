Trying to load file: pearl-necklace.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      1: f1 -> f1 : B'=1+B, [ A>=1+B ], cost: 1
      2: f1 -> f2 : C'=B, [ B>=A ], cost: 1
      3: f2 -> f2 : C'=-1+C, [ C>=1 ], cost: 1
      4: f2 -> f3 : D'=C, [ 0>=C ], cost: 1
      5: f3 -> f3 : D'=1+D, [ A>=1+D ], cost: 1
      6: f3 -> f4 : E'=D, [ D>=A ], cost: 1
      7: f4 -> f4 : E'=-1+E, [ E>=1 ], cost: 1


Try instantiation
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      8: f1 -> f1 : B'=A, [ A>=1+B ], cost: A-B
      2: f1 -> f2 : C'=B, [ B>=A ], cost: 1
      3: f2 -> f2 : C'=-1+C, [ C>=1 ], cost: 1
      4: f2 -> f3 : D'=C, [ 0>=C ], cost: 1
      5: f3 -> f3 : D'=1+D, [ A>=1+D ], cost: 1
      6: f3 -> f4 : E'=D, [ D>=A ], cost: 1
      7: f4 -> f4 : E'=-1+E, [ E>=1 ], cost: 1

Eliminating 1 self-loops for location f1
  Removing the self-loops: 8.
Adding an epsilon transition (to model nonexecution of the loops): 10.

Try instantiation
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      9: f1 -> [5] : B'=A, [ A>=1+B ], cost: A-B
     10: f1 -> [5] : [], cost: 0
     11: f2 -> f2 : C'=0, [ C>=1 ], cost: C
      4: f2 -> f3 : D'=C, [ 0>=C ], cost: 1
      5: f3 -> f3 : D'=1+D, [ A>=1+D ], cost: 1
      6: f3 -> f4 : E'=D, [ D>=A ], cost: 1
      7: f4 -> f4 : E'=-1+E, [ E>=1 ], cost: 1
      2: [5] -> f2 : C'=B, [ B>=A ], cost: 1

Eliminating 1 self-loops for location f2
  Removing the self-loops: 11.
Adding an epsilon transition (to model nonexecution of the loops): 13.

Try instantiation
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      9: f1 -> [5] : B'=A, [ A>=1+B ], cost: A-B
     10: f1 -> [5] : [], cost: 0
     12: f2 -> [6] : C'=0, [ C>=1 ], cost: C
     13: f2 -> [6] : [], cost: 0
     14: f3 -> f3 : D'=A, [ A>=1+D ], cost: A-D
      6: f3 -> f4 : E'=D, [ D>=A ], cost: 1
      7: f4 -> f4 : E'=-1+E, [ E>=1 ], cost: 1
      2: [5] -> f2 : C'=B, [ B>=A ], cost: 1
      4: [6] -> f3 : D'=C, [ 0>=C ], cost: 1

Eliminating 1 self-loops for location f3
  Removing the self-loops: 14.
Adding an epsilon transition (to model nonexecution of the loops): 16.

Try instantiation
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      9: f1 -> [5] : B'=A, [ A>=1+B ], cost: A-B
     10: f1 -> [5] : [], cost: 0
     12: f2 -> [6] : C'=0, [ C>=1 ], cost: C
     13: f2 -> [6] : [], cost: 0
     15: f3 -> [7] : D'=A, [ A>=1+D ], cost: A-D
     16: f3 -> [7] : [], cost: 0
     17: f4 -> f4 : E'=0, [ E>=1 ], cost: E
      2: [5] -> f2 : C'=B, [ B>=A ], cost: 1
      4: [6] -> f3 : D'=C, [ 0>=C ], cost: 1
      6: [7] -> f4 : E'=D, [ D>=A ], cost: 1

Eliminating 1 self-loops for location f4
  Removing the self-loops: 17.
Adding an epsilon transition (to model nonexecution of the loops): 19.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      9: f1 -> [5] : B'=A, [ A>=1+B ], cost: A-B
     10: f1 -> [5] : [], cost: 0
     12: f2 -> [6] : C'=0, [ C>=1 ], cost: C
     13: f2 -> [6] : [], cost: 0
     15: f3 -> [7] : D'=A, [ A>=1+D ], cost: A-D
     16: f3 -> [7] : [], cost: 0
     18: f4 -> [8] : E'=0, [ E>=1 ], cost: E
     19: f4 -> [8] : [], cost: 0
      2: [5] -> f2 : C'=B, [ B>=A ], cost: 1
      4: [6] -> f3 : D'=C, [ 0>=C ], cost: 1
      6: [7] -> f4 : E'=D, [ D>=A ], cost: 1


Applied chaining over branches and pruning:
  Start location: f0
     20: f0 -> [5] : B'=A, [ A>=1+B ], cost: 1+A-B
     21: f0 -> [5] : [], cost: 1
     22: [5] -> [6] : C'=0, [ B>=A && B>=1 ], cost: 1+B
     23: [5] -> [6] : C'=B, [ B>=A ], cost: 1
     24: [6] -> [7] : D'=A, [ 0>=C && A>=1+C ], cost: 1+A-C
     25: [6] -> [7] : D'=C, [ 0>=C ], cost: 1
     26: [7] -> [8] : E'=0, [ D>=A && D>=1 ], cost: 1+D


Applied chaining over branches and pruning:
  Start location: f0
     28: f0 -> [6] : B'=A, C'=0, [ A>=1+B && A>=A && A>=1 ], cost: 2+2*A-B
     29: f0 -> [6] : B'=A, C'=A, [ A>=1+B && A>=A ], cost: 2+A-B
     30: f0 -> [6] : C'=0, [ B>=A && B>=1 ], cost: 2+B
     31: f0 -> [6] : C'=B, [ B>=A ], cost: 2
     32: [6] -> [8] : D'=A, E'=0, [ 0>=C && A>=1+C && A>=A && A>=1 ], cost: 2+2*A-C


Applied chaining over branches and pruning:
  Start location: f0
     33: f0 -> [8] : B'=A, C'=0, D'=A, E'=0, [ A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1 ], cost: 4+4*A-B
     35: f0 -> [8] : C'=0, D'=A, E'=0, [ B>=A && B>=1 && 0>=0 && A>=1 && A>=A && A>=1 ], cost: 4+2*A+B
     34: f0 -> [9] : B'=A, C'=A, [ A>=1+B && A>=A ], cost: 2+A-B


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     33: f0 -> [8] : B'=A, C'=0, D'=A, E'=0, [ A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1 ], cost: 4+4*A-B
     35: f0 -> [8] : C'=0, D'=A, E'=0, [ B>=A && B>=1 && 0>=0 && A>=1 && A>=A && A>=1 ], cost: 4+2*A+B
     34: f0 -> [9] : B'=A, C'=A, [ A>=1+B && A>=A ], cost: 2+A-B


Computing complexity for remaining 3 transitions.

  Found configuration with infinitely models for cost: 4+4*A-B
  and guard: A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1:
  A: Pos, B: Pos, where: A > B

Found new complexity n^1, because: Found infinity configuration.


The final runtime is determined by this resulting transition:
  Final Guard: A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1
  Final Cost:  4+4*A-B

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: n^1
  Complexity value: 1

WORST_CASE(Omega(n^1),?)
