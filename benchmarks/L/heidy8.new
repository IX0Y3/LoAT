Trying to load file: heidy8.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f3 : A'=0, B'=0, [], cost: 1
      1: f3 -> f3 : C'=-1+C, D'=free, [ C>=1 && free>=1 ], cost: 1
      2: f3 -> f3 : C'=-2+C, D'=free_1, [ C>=1 && 0>=free_1 ], cost: 1
      3: f3 -> f6 : E'=free_2, [ 0>=C ], cost: 1
      4: f6 -> f6 : A'=1, E'=free_3, [ E>=1 ], cost: 1
      5: f6 -> f6 : A'=0, E'=free_4, [ 0>=E ], cost: 1


Try instantiation
  Start location: f0
      0: f0 -> f3 : A'=0, B'=0, [], cost: 1
      6: f3 -> f3 : C'=-2*meter+C, D'=free_1, [ -2*meter+C>=-1 && 2*meter==1+C && C>=1 ], cost: meter
      7: f3 -> f3 : C'=0, D'=free, [ C>=1 ], cost: C
      3: f3 -> f6 : E'=free_2, [ 0>=C ], cost: 1
      4: f6 -> f6 : A'=1, E'=free_3, [ E>=1 ], cost: 1
      5: f6 -> f6 : A'=0, E'=free_4, [ 0>=E ], cost: 1

Eliminating 2 self-loops for location f3
  Removing the self-loops: 6 7.
Adding an epsilon transition (to model nonexecution of the loops): 10.

Try instantiation
  Start location: f0
      0: f0 -> f3 : A'=0, B'=0, [], cost: 1
      8: f3 -> [3] : C'=-2*meter+C, D'=free_1, [ 2*meter==1+C && C>=1 ], cost: meter
      9: f3 -> [3] : C'=0, D'=free, [ C>=1 ], cost: C
     10: f3 -> [3] : [], cost: 0
     11: f6 -> f6 : [ 0>=E ], cost: INF
     12: f6 -> f6 : [ E>=1 ], cost: INF
      3: [3] -> f6 : E'=free_2, [ 0>=C ], cost: 1

Eliminating 2 self-loops for location f6
  Removing the self-loops: 11 12.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f3 : A'=0, B'=0, [], cost: 1
      8: f3 -> [3] : C'=-2*meter+C, D'=free_1, [ 2*meter==1+C && C>=1 ], cost: meter
      9: f3 -> [3] : C'=0, D'=free, [ C>=1 ], cost: C
     10: f3 -> [3] : [], cost: 0
     13: f6 -> [4] : [ 0>=E ], cost: INF
     14: f6 -> [4] : [ E>=1 ], cost: INF
      3: [3] -> f6 : E'=free_2, [ 0>=C ], cost: 1


Applied chaining over branches and pruning:
  Start location: f0
     15: f0 -> [3] : A'=0, B'=0, C'=-2*meter+C, D'=free_1, [ 2*meter==1+C && C>=1 ], cost: 1+meter
     16: f0 -> [3] : A'=0, B'=0, C'=0, D'=free, [ C>=1 ], cost: 1+C
     17: f0 -> [3] : A'=0, B'=0, [], cost: 1
     18: [3] -> [4] : E'=free_2, [ 0>=C && 0>=free_2 ], cost: INF
     19: [3] -> [4] : E'=free_2, [ 0>=C && free_2>=1 ], cost: INF


Applied chaining over branches and pruning:
  Start location: f0
     20: f0 -> [4] : A'=0, B'=0, C'=-2*meter+C, D'=free_1, E'=free_2, [ 2*meter==1+C && C>=1 && 0>=-2*meter+C && 0>=free_2 ], cost: INF
     21: f0 -> [4] : A'=0, B'=0, C'=-2*meter+C, D'=free_1, E'=free_2, [ 2*meter==1+C && C>=1 && 0>=-2*meter+C && free_2>=1 ], cost: INF
     22: f0 -> [4] : A'=0, B'=0, C'=0, D'=free, E'=free_2, [ C>=1 && 0>=0 && 0>=free_2 ], cost: INF
     23: f0 -> [4] : A'=0, B'=0, C'=0, D'=free, E'=free_2, [ C>=1 && 0>=0 && free_2>=1 ], cost: INF
     25: f0 -> [4] : A'=0, B'=0, E'=free_2, [ 0>=C && free_2>=1 ], cost: INF


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     20: f0 -> [4] : A'=0, B'=0, C'=-2*meter+C, D'=free_1, E'=free_2, [ 2*meter==1+C && C>=1 && 0>=-2*meter+C && 0>=free_2 ], cost: INF
     21: f0 -> [4] : A'=0, B'=0, C'=-2*meter+C, D'=free_1, E'=free_2, [ 2*meter==1+C && C>=1 && 0>=-2*meter+C && free_2>=1 ], cost: INF
     22: f0 -> [4] : A'=0, B'=0, C'=0, D'=free, E'=free_2, [ C>=1 && 0>=0 && 0>=free_2 ], cost: INF
     23: f0 -> [4] : A'=0, B'=0, C'=0, D'=free, E'=free_2, [ C>=1 && 0>=0 && free_2>=1 ], cost: INF
     25: f0 -> [4] : A'=0, B'=0, E'=free_2, [ 0>=C && free_2>=1 ], cost: INF


Computing complexity for remaining 5 transitions.

Found new complexity INF, because: INF sat.


The final runtime is determined by this resulting transition:
  Final Guard: 2*meter==1+C && C>=1 && 0>=-2*meter+C && 0>=free_2
  Final Cost:  INF

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: INF
  Complexity value: INF

WORST_CASE(INF,?)
