Trying to load file: Ex3.koat

Initial Control flow graph problem:
  Start location: evalEx3start
      0: evalEx3start -> evalEx3entryin : [], cost: 1
      1: evalEx3entryin -> evalEx3bb4in : [], cost: 1
      2: evalEx3bb4in -> evalEx3bbin : [ A>=1 ], cost: 1
      3: evalEx3bb4in -> evalEx3returnin : [ 0>=A ], cost: 1
      4: evalEx3bbin -> evalEx3bb2in : B'=free, C'=A, [], cost: 1
     11: evalEx3returnin -> evalEx3stop : [], cost: 1
      5: evalEx3bb2in -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
      6: evalEx3bb2in -> evalEx3bb3in : [ C>=1 ], cost: 1
      8: evalEx3bb3in -> evalEx3bb4in : A'=C, [ B>=1+free_1 ], cost: 1
      9: evalEx3bb3in -> evalEx3bb4in : A'=C, [ free_2>=1+B ], cost: 1
      7: evalEx3bb3in -> evalEx3bb1in : [], cost: 1
     10: evalEx3bb1in -> evalEx3bb2in : C'=-1+C, [], cost: 1

Removing duplicate transition: 8.

Simplified the transitions:
  Start location: evalEx3start
      0: evalEx3start -> evalEx3entryin : [], cost: 1
      1: evalEx3entryin -> evalEx3bb4in : [], cost: 1
      2: evalEx3bb4in -> evalEx3bbin : [ A>=1 ], cost: 1
      4: evalEx3bbin -> evalEx3bb2in : B'=free, C'=A, [], cost: 1
      5: evalEx3bb2in -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
      6: evalEx3bb2in -> evalEx3bb3in : [ C>=1 ], cost: 1
      9: evalEx3bb3in -> evalEx3bb4in : A'=C, [], cost: 1
      7: evalEx3bb3in -> evalEx3bb1in : [], cost: 1
     10: evalEx3bb1in -> evalEx3bb2in : C'=-1+C, [], cost: 1


Applied simple chaining:
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
      2: evalEx3bb4in -> evalEx3bb2in : B'=free, C'=A, [ A>=1 ], cost: 2
      5: evalEx3bb2in -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
      6: evalEx3bb2in -> evalEx3bb3in : [ C>=1 ], cost: 1
      9: evalEx3bb3in -> evalEx3bb4in : A'=C, [], cost: 1
      7: evalEx3bb3in -> evalEx3bb2in : C'=-1+C, [], cost: 2


Applied chaining over branches and pruning:
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
      2: evalEx3bb4in -> evalEx3bb2in : B'=free, C'=A, [ A>=1 ], cost: 2
      5: evalEx3bb2in -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
     12: evalEx3bb2in -> evalEx3bb4in : A'=C, [ C>=1 ], cost: 2
     13: evalEx3bb2in -> evalEx3bb2in : C'=-1+C, [ C>=1 ], cost: 3


Try instantiation
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
      2: evalEx3bb4in -> evalEx3bb2in : B'=free, C'=A, [ A>=1 ], cost: 2
      5: evalEx3bb2in -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
     12: evalEx3bb2in -> evalEx3bb4in : A'=C, [ C>=1 ], cost: 2
     14: evalEx3bb2in -> evalEx3bb2in : C'=0, [ C>=1 ], cost: 3*C

Eliminating 1 self-loops for location evalEx3bb2in
  Removing the self-loops: 14.
Adding an epsilon transition (to model nonexecution of the loops): 16.

Removed all Self-loops using metering functions (where possible):
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
      2: evalEx3bb4in -> evalEx3bb2in : B'=free, C'=A, [ A>=1 ], cost: 2
     15: evalEx3bb2in -> [9] : C'=0, [ C>=1 ], cost: 3*C
     16: evalEx3bb2in -> [9] : [], cost: 0
      5: [9] -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
     12: [9] -> evalEx3bb4in : A'=C, [ C>=1 ], cost: 2


Applied chaining over branches and pruning:
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
     17: evalEx3bb4in -> [9] : B'=free, C'=0, [ A>=1 && A>=1 ], cost: 2+3*A
     18: evalEx3bb4in -> [9] : B'=free, C'=A, [ A>=1 ], cost: 2
      5: [9] -> evalEx3bb4in : A'=C, [ 0>=C ], cost: 1
     12: [9] -> evalEx3bb4in : A'=C, [ C>=1 ], cost: 2


Applied chaining over branches and pruning:
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
     19: evalEx3bb4in -> evalEx3bb4in : A'=0, B'=free, C'=0, [ A>=1 && A>=1 && 0>=0 ], cost: 3+3*A
     21: evalEx3bb4in -> evalEx3bb4in : A'=A, B'=free, C'=A, [ A>=1 && A>=1 ], cost: 4
     20: evalEx3bb4in -> [10] : B'=free, C'=0, [ A>=1 && A>=1 ], cost: 2+3*A


Try instantiation
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
     22: evalEx3bb4in -> evalEx3bb4in : [ A>=1 ], cost: INF
     20: evalEx3bb4in -> [10] : B'=free, C'=0, [ A>=1 && A>=1 ], cost: 2+3*A

Eliminating 1 self-loops for location evalEx3bb4in
  Removing the self-loops: 22.

Removed all Self-loops using metering functions (where possible):
  Start location: evalEx3start
      0: evalEx3start -> evalEx3bb4in : [], cost: 2
     23: evalEx3bb4in -> [11] : [ A>=1 ], cost: INF
     20: [11] -> [10] : B'=free, C'=0, [ A>=1 && A>=1 ], cost: 2+3*A


Applied simple chaining:
  Start location: evalEx3start
      0: evalEx3start -> [10] : B'=free, C'=0, [ A>=1 && A>=1 && A>=1 ], cost: INF


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: evalEx3start
      0: evalEx3start -> [10] : B'=free, C'=0, [ A>=1 && A>=1 && A>=1 ], cost: INF


Computing complexity for remaining 1 transitions.

Found new complexity INF, because: INF sat.


The final runtime is determined by this resulting transition:
  Final Guard: A>=1 && A>=1 && A>=1
  Final Cost:  INF

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: INF
  Complexity value: INF

WORST_CASE(INF,?)
