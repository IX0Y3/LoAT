Trying to load file: pearl-necklace.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      1: f1 -> f1 : B'=1+B, [ A>=1+B ], cost: 1
      2: f1 -> f2 : C'=B, [ B>=A ], cost: 1
      3: f2 -> f2 : C'=-1+C, [ C>=1 ], cost: 1
      4: f2 -> f3 : D'=C, [ 0>=C ], cost: 1
      5: f3 -> f3 : D'=1+D, [ A>=1+D ], cost: 1
      6: f3 -> f4 : E'=D, [ D>=A ], cost: 1
      7: f4 -> f4 : E'=-1+E, [ E>=1 ], cost: 1

Eliminating 1 self-loops for location f1
  Self-Loop 1 has the metering function: -B+A, resulting in the new transition 8.
  Removing the self-loops: 1.
Eliminating 1 self-loops for location f2
  Self-Loop 3 has the metering function: C, resulting in the new transition 9.
  Removing the self-loops: 3.
Eliminating 1 self-loops for location f3
  Self-Loop 5 has the metering function: A-D, resulting in the new transition 10.
  Removing the self-loops: 5.
Eliminating 1 self-loops for location f4
  Self-Loop 7 has the metering function: E, resulting in the new transition 11.
  Removing the self-loops: 7.

Accelerated all simple loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f1 : [], cost: 1
      8: f1 -> f1 : B'=A, [ A>=1+B ], cost: -B+A
      2: f1 -> f2 : C'=B, [ B>=A ], cost: 1
      9: f2 -> f2 : C'=0, [ C>=1 ], cost: C
      4: f2 -> f3 : D'=C, [ 0>=C ], cost: 1
     10: f3 -> f3 : D'=A, [ A>=1+D ], cost: A-D
      6: f3 -> f4 : E'=D, [ D>=A ], cost: 1
     11: f4 -> f4 : E'=0, [ E>=1 ], cost: E


Chained simpled loops:
  Start location: f0
     12: f0 -> f1 : B'=A, [ A>=1+B ], cost: 1-B+A
     13: f1 -> f2 : C'=0, [ B>=A && B>=1 ], cost: 1+B
     14: f2 -> f3 : D'=A, [ 0>=C && A>=1+C ], cost: 1+A-C
     15: f3 -> f4 : E'=0, [ D>=A && D>=1 ], cost: 1+D


Eliminated locations (linear):
  Start location: f0
     12: f0 -> f4 : B'=A, C'=0, D'=A, E'=0, [ A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1 ], cost: 4-B+4*A


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     12: f0 -> f4 : B'=A, C'=0, D'=A, E'=0, [ A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1 ], cost: 4-B+4*A


Computing complexity for remaining 1 transitions.

Created initial limit problem:
1 (+/+!), A (+/+!), 4-B+4*A (+), -B+A (+/+!) [not solved]

applying transformation rule (C) using substitution {A==1+B}
resulting limit problem:
1 (+/+!), 8+3*B (+), 1+B (+/+!) [not solved]

applying transformation rule (C) using substitution {A==1}
resulting limit problem:
1 (+/+!), 8+3*B (+), 1+B (+/+!) [not solved]

applying transformation rule (C) using substitution {A==1}
resulting limit problem:
1 (+/+!), 8+3*B (+), 1+B (+/+!) [not solved]

applying transformation rule (C) using substitution {A==1}
resulting limit problem:
1 (+/+!), 8+3*B (+), 1+B (+/+!) [not solved]

applying transformation rule (B), deleting 1 (+/+!)
resulting limit problem:
8+3*B (+), 1+B (+/+!) [not solved]

applying transformation rule (D), replacing 8+3*B (+) by 3*B (+)
resulting limit problem:
1+B (+/+!), 3*B (+) [not solved]

applying transformation rule (D), replacing 1+B (+/+!) by B (+)
resulting limit problem:
B (+), 3*B (+) [not solved]

applying transformation rule (A), replacing 3*B (+) by B (+) and 3 (+!) using + limit vector (+,+!)
resulting limit problem:
B (+), 3 (+!) [not solved]

applying transformation rule (B), deleting 3 (+!)
resulting limit problem:
B (+) [solved]

Solution:
B / n
A / 1+n
Found new complexity n^1, because: Solved the initial limit problem.


The final runtime is determined by this resulting transition:
  Final Guard: A>=1+B && A>=A && A>=1 && 0>=0 && A>=1 && A>=A && A>=1
  Final Cost:  8+3*n

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: n^1
  Complexity value: 1

WORST_CASE(Omega(n^1),?)
