Trying to load file: nestedLoop_1.koat

Initial Control flow graph problem:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopentryin : [], cost: 1
      1: evalnestedLoopentryin -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 1
      2: evalnestedLoopentryin -> evalnestedLoopreturnin : [ 0>=1+A ], cost: 1
      3: evalnestedLoopentryin -> evalnestedLoopreturnin : [ 0>=1+B ], cost: 1
      4: evalnestedLoopentryin -> evalnestedLoopreturnin : [ 0>=1+C ], cost: 1
      6: evalnestedLoopbb9in -> evalnestedLoopreturnin : [ D>=A ], cost: 1
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
     14: evalnestedLoopreturnin -> evalnestedLoopstop : [], cost: 1
      7: evalnestedLoopbb7in -> evalnestedLoopbb4in : [ B>=1+E ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb8in : [ E>=B ], cost: 1
      9: evalnestedLoopbb4in -> evalnestedLoopbb6in : G'=1+E, H'=F, [], cost: 1
     13: evalnestedLoopbb8in -> evalnestedLoopbb9in : D'=1+F, [], cost: 1
     11: evalnestedLoopbb6in -> evalnestedLoopbb7in : E'=G, F'=H, [ H>=C ], cost: 1
     10: evalnestedLoopbb6in -> evalnestedLoopbb5in : [ C>=1+H ], cost: 1
     12: evalnestedLoopbb5in -> evalnestedLoopbb6in : H'=1+H, [], cost: 1


Simplified the transitions:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopentryin : [], cost: 1
      1: evalnestedLoopentryin -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 1
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      7: evalnestedLoopbb7in -> evalnestedLoopbb4in : [ B>=1+E ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb8in : [ E>=B ], cost: 1
      9: evalnestedLoopbb4in -> evalnestedLoopbb6in : G'=1+E, H'=F, [], cost: 1
     13: evalnestedLoopbb8in -> evalnestedLoopbb9in : D'=1+F, [], cost: 1
     11: evalnestedLoopbb6in -> evalnestedLoopbb7in : E'=G, F'=H, [ H>=C ], cost: 1
     10: evalnestedLoopbb6in -> evalnestedLoopbb5in : [ C>=1+H ], cost: 1
     12: evalnestedLoopbb5in -> evalnestedLoopbb6in : H'=1+H, [], cost: 1


Applied simple chaining:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2
      7: evalnestedLoopbb7in -> evalnestedLoopbb6in : G'=1+E, H'=F, [ B>=1+E ], cost: 2
     11: evalnestedLoopbb6in -> evalnestedLoopbb7in : E'=G, F'=H, [ H>=C ], cost: 1
     10: evalnestedLoopbb6in -> evalnestedLoopbb6in : H'=1+H, [ C>=1+H ], cost: 2


Try instantiation
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2
      7: evalnestedLoopbb7in -> evalnestedLoopbb6in : G'=1+E, H'=F, [ B>=1+E ], cost: 2
     11: evalnestedLoopbb6in -> evalnestedLoopbb7in : E'=G, F'=H, [ H>=C ], cost: 1
     15: evalnestedLoopbb6in -> evalnestedLoopbb6in : H'=C, [ C>=1+H ], cost: 2*C-2*H

Eliminating 1 self-loops for location evalnestedLoopbb6in
  Removing the self-loops: 15.
Adding an epsilon transition (to model nonexecution of the loops): 17.

Removed all Self-loops using metering functions (where possible):
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2
      7: evalnestedLoopbb7in -> evalnestedLoopbb6in : G'=1+E, H'=F, [ B>=1+E ], cost: 2
     16: evalnestedLoopbb6in -> [10] : H'=C, [ C>=1+H ], cost: 2*C-2*H
     17: evalnestedLoopbb6in -> [10] : [], cost: 0
     11: [10] -> evalnestedLoopbb7in : E'=G, F'=H, [ H>=C ], cost: 1


Applied chaining over branches and pruning:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2
     18: evalnestedLoopbb7in -> [10] : G'=1+E, H'=C, [ B>=1+E && C>=1+F ], cost: 2-2*F+2*C
     19: evalnestedLoopbb7in -> [10] : G'=1+E, H'=F, [ B>=1+E ], cost: 2
     11: [10] -> evalnestedLoopbb7in : E'=G, F'=H, [ H>=C ], cost: 1


Applied chaining over branches and pruning:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2
     20: evalnestedLoopbb7in -> evalnestedLoopbb7in : E'=1+E, F'=C, G'=1+E, H'=C, [ B>=1+E && C>=1+F && C>=C ], cost: 3-2*F+2*C
     21: evalnestedLoopbb7in -> evalnestedLoopbb7in : E'=1+E, F'=F, G'=1+E, H'=F, [ B>=1+E && F>=C ], cost: 3


Try instantiation
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: evalnestedLoopbb7in -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2
     22: evalnestedLoopbb7in -> evalnestedLoopbb7in : E'=B, F'=F, G'=B, H'=F, [ B>=1+E && F>=C ], cost: -3*E+3*B

Eliminating 1 self-loops for location evalnestedLoopbb7in
  Removing the self-loops: 22.
Adding an epsilon transition (to model nonexecution of the loops): 24.

Removed all Self-loops using metering functions (where possible):
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
      5: evalnestedLoopbb9in -> evalnestedLoopbb7in : E'=0, F'=D, [ A>=1+D ], cost: 1
     23: evalnestedLoopbb7in -> [11] : E'=B, G'=B, H'=F, [ B>=1+E && F>=C ], cost: -3*E+3*B
     24: evalnestedLoopbb7in -> [11] : [], cost: 0
      8: [11] -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2


Applied chaining over branches and pruning:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
     25: evalnestedLoopbb9in -> [11] : E'=B, F'=D, G'=B, H'=D, [ A>=1+D && B>=1 && D>=C ], cost: 1+3*B
     26: evalnestedLoopbb9in -> [11] : E'=0, F'=D, [ A>=1+D ], cost: 1
      8: [11] -> evalnestedLoopbb9in : D'=1+F, [ E>=B ], cost: 2


Applied chaining over branches and pruning:
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
     27: evalnestedLoopbb9in -> evalnestedLoopbb9in : D'=1+D, E'=B, F'=D, G'=B, H'=D, [ A>=1+D && B>=1 && D>=C && B>=B ], cost: 3+3*B
     28: evalnestedLoopbb9in -> evalnestedLoopbb9in : D'=1+D, E'=0, F'=D, [ A>=1+D && 0>=B ], cost: 3


Try instantiation
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
     29: evalnestedLoopbb9in -> evalnestedLoopbb9in : D'=A, E'=0, F'=-1+A, [ A>=1+D && 0>=B ], cost: -3*D+3*A
     30: evalnestedLoopbb9in -> evalnestedLoopbb9in : D'=A, E'=B, F'=-1+A, G'=B, H'=-1+A, [ A>=1+D && D>=C && B>=1 ], cost: -3*D-3*(D-A)*B+3*A

Eliminating 2 self-loops for location evalnestedLoopbb9in
  Removing the self-loops: 29 30.
Adding an epsilon transition (to model nonexecution of the loops): 33.

Removed all Self-loops using metering functions (where possible):
  Start location: evalnestedLoopstart
      0: evalnestedLoopstart -> evalnestedLoopbb9in : D'=0, [ A>=0 && B>=0 && C>=0 ], cost: 2
     31: evalnestedLoopbb9in -> [12] : D'=A, E'=0, F'=-1+A, [ A>=1+D && 0>=B ], cost: -3*D+3*A
     32: evalnestedLoopbb9in -> [12] : D'=A, E'=B, F'=-1+A, G'=B, H'=-1+A, [ A>=1+D && D>=C && B>=1 ], cost: -3*D-3*(D-A)*B+3*A
     33: evalnestedLoopbb9in -> [12] : [], cost: 0


Applied chaining over branches and pruning:
  Start location: evalnestedLoopstart
     34: evalnestedLoopstart -> [12] : D'=A, E'=0, F'=-1+A, [ A>=0 && B>=0 && C>=0 && A>=1 && 0>=B ], cost: 2+3*A
     35: evalnestedLoopstart -> [12] : D'=A, E'=B, F'=-1+A, G'=B, H'=-1+A, [ A>=0 && B>=0 && C>=0 && A>=1 && 0>=C && B>=1 ], cost: 2+3*B*A+3*A


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: evalnestedLoopstart
     34: evalnestedLoopstart -> [12] : D'=A, E'=0, F'=-1+A, [ A>=0 && B>=0 && C>=0 && A>=1 && 0>=B ], cost: 2+3*A
     35: evalnestedLoopstart -> [12] : D'=A, E'=B, F'=-1+A, G'=B, H'=-1+A, [ A>=0 && B>=0 && C>=0 && A>=1 && 0>=C && B>=1 ], cost: 2+3*B*A+3*A


Computing complexity for remaining 2 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
