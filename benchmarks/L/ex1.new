Trying to load file: ex1.koat

Initial Control flow graph problem:
  Start location: evalfstart
      0: evalfstart -> evalfentryin : [], cost: 1
      1: evalfentryin -> evalfbb7in : A'=B, C'=0, [], cost: 1
      2: evalfbb7in -> evalfbbin : [ A>=0 && C>=0 ], cost: 1
      3: evalfbb7in -> evalfreturnin : [ 0>=1+A ], cost: 1
      4: evalfbb7in -> evalfreturnin : [ 0>=1+C ], cost: 1
      5: evalfbbin -> evalfbb3in : D'=C, [ 0>=1+free ], cost: 1
      6: evalfbbin -> evalfbb3in : D'=C, [ free_1>=1 ], cost: 1
      7: evalfbbin -> evalfbb6in : D'=A, E'=C, [], cost: 1
     16: evalfreturnin -> evalfstop : [], cost: 1
      8: evalfbb3in -> evalfbb5in : [ D>=1+B ], cost: 1
      9: evalfbb3in -> evalfbb4in : [ B>=D ], cost: 1
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     14: evalfbb5in -> evalfbb6in : D'=-1+A, E'=D, [], cost: 1
     12: evalfbb4in -> evalfbb5in : [], cost: 1
     10: evalfbb4in -> evalfbb2in : [ 0>=1+free_2 ], cost: 1
     11: evalfbb4in -> evalfbb2in : [ free_3>=1 ], cost: 1
     13: evalfbb2in -> evalfbb3in : D'=1+D, [], cost: 1

Removing duplicate transition: 5.
Removing duplicate transition: 10.

Simplified the transitions:
  Start location: evalfstart
      0: evalfstart -> evalfentryin : [], cost: 1
      1: evalfentryin -> evalfbb7in : A'=B, C'=0, [], cost: 1
      2: evalfbb7in -> evalfbbin : [ A>=0 && C>=0 ], cost: 1
      6: evalfbbin -> evalfbb3in : D'=C, [], cost: 1
      7: evalfbbin -> evalfbb6in : D'=A, E'=C, [], cost: 1
      8: evalfbb3in -> evalfbb5in : [ D>=1+B ], cost: 1
      9: evalfbb3in -> evalfbb4in : [ B>=D ], cost: 1
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     14: evalfbb5in -> evalfbb6in : D'=-1+A, E'=D, [], cost: 1
     12: evalfbb4in -> evalfbb5in : [], cost: 1
     11: evalfbb4in -> evalfbb2in : [], cost: 1
     13: evalfbb2in -> evalfbb3in : D'=1+D, [], cost: 1


Applied simple chaining:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
      2: evalfbb7in -> evalfbbin : [ A>=0 && C>=0 ], cost: 1
      6: evalfbbin -> evalfbb3in : D'=C, [], cost: 1
      7: evalfbbin -> evalfbb6in : D'=A, E'=C, [], cost: 1
      8: evalfbb3in -> evalfbb5in : [ D>=1+B ], cost: 1
      9: evalfbb3in -> evalfbb4in : [ B>=D ], cost: 1
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     14: evalfbb5in -> evalfbb6in : D'=-1+A, E'=D, [], cost: 1
     11: evalfbb4in -> evalfbb3in : D'=1+D, [], cost: 2
     12: evalfbb4in -> evalfbb5in : [], cost: 1


Applied chaining over branches and pruning:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     17: evalfbb7in -> evalfbb3in : D'=C, [ A>=0 && C>=0 ], cost: 2
     18: evalfbb7in -> evalfbb6in : D'=A, E'=C, [ A>=0 && C>=0 ], cost: 2
     19: evalfbb3in -> evalfbb3in : D'=1+D, [ B>=D ], cost: 3
      8: evalfbb3in -> evalfbb5in : [ D>=1+B ], cost: 1
     20: evalfbb3in -> evalfbb5in : [ B>=D ], cost: 2
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     14: evalfbb5in -> evalfbb6in : D'=-1+A, E'=D, [], cost: 1


Try instantiation
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     17: evalfbb7in -> evalfbb3in : D'=C, [ A>=0 && C>=0 ], cost: 2
     18: evalfbb7in -> evalfbb6in : D'=A, E'=C, [ A>=0 && C>=0 ], cost: 2
     21: evalfbb3in -> evalfbb3in : D'=1+B, [ B>=D ], cost: 3-3*D+3*B
      8: evalfbb3in -> evalfbb5in : [ D>=1+B ], cost: 1
     20: evalfbb3in -> evalfbb5in : [ B>=D ], cost: 2
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     14: evalfbb5in -> evalfbb6in : D'=-1+A, E'=D, [], cost: 1

Eliminating 1 self-loops for location evalfbb3in
  Removing the self-loops: 21.
Adding an epsilon transition (to model nonexecution of the loops): 23.

Removed all Self-loops using metering functions (where possible):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     17: evalfbb7in -> evalfbb3in : D'=C, [ A>=0 && C>=0 ], cost: 2
     18: evalfbb7in -> evalfbb6in : D'=A, E'=C, [ A>=0 && C>=0 ], cost: 2
     22: evalfbb3in -> [11] : D'=1+B, [ B>=D ], cost: 3-3*D+3*B
     23: evalfbb3in -> [11] : [], cost: 0
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     14: evalfbb5in -> evalfbb6in : D'=-1+A, E'=D, [], cost: 1
      8: [11] -> evalfbb5in : [ D>=1+B ], cost: 1
     20: [11] -> evalfbb5in : [ B>=D ], cost: 2


Applied chaining over branches and pruning:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     18: evalfbb7in -> evalfbb6in : D'=A, E'=C, [ A>=0 && C>=0 ], cost: 2
     24: evalfbb7in -> [11] : D'=1+B, [ A>=0 && C>=0 && B>=C ], cost: 5-3*C+3*B
     25: evalfbb7in -> [11] : D'=C, [ A>=0 && C>=0 ], cost: 2
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1
     26: [11] -> evalfbb6in : D'=-1+A, E'=D, [ D>=1+B ], cost: 2
     27: [11] -> evalfbb6in : D'=-1+A, E'=D, [ B>=D ], cost: 3


Applied chaining over branches and pruning:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     18: evalfbb7in -> evalfbb6in : D'=A, E'=C, [ A>=0 && C>=0 ], cost: 2
     28: evalfbb7in -> evalfbb6in : D'=-1+A, E'=1+B, [ A>=0 && C>=0 && B>=C && 1+B>=1+B ], cost: 7-3*C+3*B
     30: evalfbb7in -> evalfbb6in : D'=-1+A, E'=C, [ A>=0 && C>=0 && C>=1+B ], cost: 4
     31: evalfbb7in -> evalfbb6in : D'=-1+A, E'=C, [ A>=0 && C>=0 && B>=C ], cost: 5
     29: evalfbb7in -> [12] : D'=1+B, [ A>=0 && C>=0 && B>=C ], cost: 5-3*C+3*B
     15: evalfbb6in -> evalfbb7in : A'=D, C'=-1+E, [], cost: 1


Applied chaining over branches and pruning:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     32: evalfbb7in -> evalfbb7in : A'=A, C'=-1+C, D'=A, E'=C, [ A>=0 && C>=0 ], cost: 3
     33: evalfbb7in -> evalfbb7in : A'=-1+A, C'=B, D'=-1+A, E'=1+B, [ A>=0 && C>=0 && B>=C && 1+B>=1+B ], cost: 8-3*C+3*B
     34: evalfbb7in -> evalfbb7in : A'=-1+A, C'=-1+C, D'=-1+A, E'=C, [ A>=0 && C>=0 && C>=1+B ], cost: 5
     35: evalfbb7in -> evalfbb7in : A'=-1+A, C'=-1+C, D'=-1+A, E'=C, [ A>=0 && C>=0 && B>=C ], cost: 6
     29: evalfbb7in -> [12] : D'=1+B, [ A>=0 && C>=0 && B>=C ], cost: 5-3*C+3*B


Try instantiation
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     36: evalfbb7in -> evalfbb7in : A'=-1, C'=-1-A+C, D'=-1, E'=-A+C, [ -A+C>=0 && B>=C && A>=0 && C>=0 && B>=-A+C ], cost: 6+6*A
     37: evalfbb7in -> evalfbb7in : A'=-1+A-C, C'=-1, D'=-1+A-C, E'=0, [ A-C>=0 && B>=C && A>=0 && C>=0 && B>=0 ], cost: 6+6*C
     38: evalfbb7in -> evalfbb7in : A'=A-C+B, C'=B, D'=A-C+B, E'=1+B, [ B>=-1 && C>=1+B && A>=0 && C>=0 && A-C+B>=-1 ], cost: 5*C-5*B
     39: evalfbb7in -> evalfbb7in : A'=-1, C'=-1-A+C, D'=-1, E'=-A+C, [ -A+C>=0 && C>=1+B && A>=0 && C>=0 && -A+C>=1+B ], cost: 5+5*A
     40: evalfbb7in -> evalfbb7in : A'=-1+A-C, C'=-1, D'=-1+A-C, E'=0, [ A-C>=0 && C>=1+B && A>=0 && C>=0 && -1>=B ], cost: 5+5*C
     41: evalfbb7in -> evalfbb7in : A'=-1, C'=B, D'=-1, E'=1+B, [ B>=0 && B>=C && A>=0 && C>=0 ], cost: 8+8*A
     42: evalfbb7in -> evalfbb7in : A'=A, C'=-1, D'=A, E'=0, [ A>=0 && C>=0 ], cost: 3+3*C
     29: evalfbb7in -> [12] : D'=1+B, [ A>=0 && C>=0 && B>=C ], cost: 5-3*C+3*B

Eliminating 7 self-loops for location evalfbb7in
  Removing the self-loops: 36 37 38 39 40 41 42.
Adding an epsilon transition (to model nonexecution of the loops): 50.

Removed all Self-loops using metering functions (where possible):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=B, C'=0, [], cost: 2
     43: evalfbb7in -> [13] : A'=-1, C'=-1-A+C, D'=-1, E'=-A+C, [ -A+C>=0 && B>=C && A>=0 && C>=0 && B>=-A+C ], cost: 6+6*A
     44: evalfbb7in -> [13] : A'=-1+A-C, C'=-1, D'=-1+A-C, E'=0, [ A-C>=0 && B>=C && A>=0 && C>=0 && B>=0 ], cost: 6+6*C
     45: evalfbb7in -> [13] : A'=A-C+B, C'=B, D'=A-C+B, E'=1+B, [ B>=-1 && C>=1+B && A>=0 && C>=0 && A-C+B>=-1 ], cost: 5*C-5*B
     46: evalfbb7in -> [13] : A'=-1, C'=-1-A+C, D'=-1, E'=-A+C, [ -A+C>=0 && C>=1+B && A>=0 && C>=0 && -A+C>=1+B ], cost: 5+5*A
     47: evalfbb7in -> [13] : A'=-1+A-C, C'=-1, D'=-1+A-C, E'=0, [ A-C>=0 && C>=1+B && A>=0 && C>=0 && -1>=B ], cost: 5+5*C
     48: evalfbb7in -> [13] : A'=-1, C'=B, D'=-1, E'=1+B, [ B>=0 && B>=C && A>=0 && C>=0 ], cost: 8+8*A
     49: evalfbb7in -> [13] : C'=-1, D'=A, E'=0, [ A>=0 && C>=0 ], cost: 3+3*C
     50: evalfbb7in -> [13] : [], cost: 0
     29: [13] -> [12] : D'=1+B, [ A>=0 && C>=0 && B>=C ], cost: 5-3*C+3*B


Applied chaining over branches and pruning:
  Start location: evalfstart
     51: evalfstart -> [13] : A'=-1, C'=-1-B, D'=-1, E'=-B, [ -B>=0 && B>=0 && B>=0 && 0>=0 && B>=-B ], cost: 8+6*B
     52: evalfstart -> [13] : A'=-1+B, C'=-1, D'=-1+B, E'=0, [ B>=0 && B>=0 && B>=0 && 0>=0 && B>=0 ], cost: 8
     53: evalfstart -> [13] : A'=-1, C'=B, D'=-1, E'=1+B, [ B>=0 && B>=0 && B>=0 && 0>=0 ], cost: 10+8*B
     54: evalfstart -> [13] : A'=B, C'=-1, D'=B, E'=0, [ B>=0 && 0>=0 ], cost: 5
     55: evalfstart -> [13] : A'=B, C'=0, [], cost: 2
     29: [13] -> [12] : D'=1+B, [ A>=0 && C>=0 && B>=C ], cost: 5-3*C+3*B


Applied chaining over branches and pruning:
  Start location: evalfstart
     58: evalfstart -> [12] : A'=B, C'=0, D'=1+B, [ B>=0 && 0>=0 && B>=0 ], cost: 7+3*B
     56: evalfstart -> [14] : A'=-1, C'=-1-B, D'=-1, E'=-B, [ -B>=0 && B>=0 && B>=0 && 0>=0 && B>=-B ], cost: 8+6*B
     57: evalfstart -> [15] : A'=-1, C'=B, D'=-1, E'=1+B, [ B>=0 && B>=0 && B>=0 && 0>=0 ], cost: 10+8*B


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: evalfstart
     58: evalfstart -> [12] : A'=B, C'=0, D'=1+B, [ B>=0 && 0>=0 && B>=0 ], cost: 7+3*B
     56: evalfstart -> [14] : A'=-1, C'=-1-B, D'=-1, E'=-B, [ -B>=0 && B>=0 && B>=0 && 0>=0 && B>=-B ], cost: 8+6*B
     57: evalfstart -> [15] : A'=-1, C'=B, D'=-1, E'=1+B, [ B>=0 && B>=0 && B>=0 && 0>=0 ], cost: 10+8*B


Computing complexity for remaining 3 transitions.

  Found configuration with infinitely models for cost: 7+3*B
  and guard: B>=0 && 0>=0 && B>=0:
  B: Pos

Found new complexity n^1, because: Found infinity configuration.


The final runtime is determined by this resulting transition:
  Final Guard: B>=0 && 0>=0 && B>=0
  Final Cost:  7+3*B

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: n^1
  Complexity value: 1

WORST_CASE(Omega(n^1),?)
