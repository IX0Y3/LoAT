Trying to load file: rsd.koat

Initial Control flow graph problem:
  Start location: evalrsdstart
      0: evalrsdstart -> evalrsdentryin : [], cost: 1
      1: evalrsdentryin -> evalrsdbbin : [ A>=0 ], cost: 1
      2: evalrsdentryin -> evalrsdreturnin : [ 0>=1+A ], cost: 1
      3: evalrsdbbin -> evalrsdbb4in : B'=2*A, C'=2*A, [], cost: 1
     11: evalrsdreturnin -> evalrsdstop : [], cost: 1
      5: evalrsdbb4in -> evalrsdreturnin : [ A>=1+C ], cost: 1
      4: evalrsdbb4in -> evalrsdbb1in : [ C>=A ], cost: 1
      6: evalrsdbb1in -> evalrsdbb2in : [ 0>=1+free ], cost: 1
      7: evalrsdbb1in -> evalrsdbb2in : [ free_1>=1 ], cost: 1
      8: evalrsdbb1in -> evalrsdbb3in : [], cost: 1
      9: evalrsdbb2in -> evalrsdbb4in : C'=-1+C, [], cost: 1
     10: evalrsdbb3in -> evalrsdbb4in : B'=-1+B, C'=-1+B, [], cost: 1

Removing duplicate transition: 6.

Simplified the transitions:
  Start location: evalrsdstart
      0: evalrsdstart -> evalrsdentryin : [], cost: 1
      1: evalrsdentryin -> evalrsdbbin : [ A>=0 ], cost: 1
      3: evalrsdbbin -> evalrsdbb4in : B'=2*A, C'=2*A, [], cost: 1
      4: evalrsdbb4in -> evalrsdbb1in : [ C>=A ], cost: 1
      7: evalrsdbb1in -> evalrsdbb2in : [], cost: 1
      8: evalrsdbb1in -> evalrsdbb3in : [], cost: 1
      9: evalrsdbb2in -> evalrsdbb4in : C'=-1+C, [], cost: 1
     10: evalrsdbb3in -> evalrsdbb4in : B'=-1+B, C'=-1+B, [], cost: 1


Applied simple chaining:
  Start location: evalrsdstart
      0: evalrsdstart -> evalrsdbb4in : B'=2*A, C'=2*A, [ A>=0 ], cost: 3
      4: evalrsdbb4in -> evalrsdbb1in : [ C>=A ], cost: 1
      7: evalrsdbb1in -> evalrsdbb4in : C'=-1+C, [], cost: 2
      8: evalrsdbb1in -> evalrsdbb4in : B'=-1+B, C'=-1+B, [], cost: 2


Applied chaining over branches and pruning:
  Start location: evalrsdstart
      0: evalrsdstart -> evalrsdbb4in : B'=2*A, C'=2*A, [ A>=0 ], cost: 3
     12: evalrsdbb4in -> evalrsdbb4in : C'=-1+C, [ C>=A ], cost: 3
     13: evalrsdbb4in -> evalrsdbb4in : B'=-1+B, C'=-1+B, [ C>=A ], cost: 3


Try instantiation
  Start location: evalrsdstart
      0: evalrsdstart -> evalrsdbb4in : B'=2*A, C'=2*A, [ A>=0 ], cost: 3
     14: evalrsdbb4in -> evalrsdbb4in : B'=A, C'=A, [ C>=A ], cost: 3*B-3*A
     15: evalrsdbb4in -> evalrsdbb4in : C'=-1+A, [ C>=A ], cost: 3+3*C-3*A

Eliminating 2 self-loops for location evalrsdbb4in
  Self-Loop 14 has unbounded runtime, resulting in the new transition 16.
  Removing the self-loops: 14 15.
Adding an epsilon transition (to model nonexecution of the loops): 18.

Removed all Self-loops using metering functions (where possible):
  Start location: evalrsdstart
      0: evalrsdstart -> evalrsdbb4in : B'=2*A, C'=2*A, [ A>=0 ], cost: 3
     16: evalrsdbb4in -> [9] : [ C>=A ], cost: INF
     17: evalrsdbb4in -> [9] : C'=-1+A, [ C>=A ], cost: 3+3*C-3*A
     18: evalrsdbb4in -> [9] : [], cost: 0


Applied chaining over branches and pruning:
  Start location: evalrsdstart
     19: evalrsdstart -> [9] : B'=2*A, C'=2*A, [ A>=0 && 2*A>=A ], cost: INF
     20: evalrsdstart -> [9] : B'=2*A, C'=-1+A, [ A>=0 && 2*A>=A ], cost: 6+3*A


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: evalrsdstart
     19: evalrsdstart -> [9] : B'=2*A, C'=2*A, [ A>=0 && 2*A>=A ], cost: INF
     20: evalrsdstart -> [9] : B'=2*A, C'=-1+A, [ A>=0 && 2*A>=A ], cost: 6+3*A


Computing complexity for remaining 2 transitions.

Found new complexity INF, because: INF sat.


The final runtime is determined by this resulting transition:
  Final Guard: A>=0 && 2*A>=A
  Final Cost:  INF

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: INF
  Complexity value: INF

WORST_CASE(INF,?)
