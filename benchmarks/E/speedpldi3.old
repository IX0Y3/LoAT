Trying to load file: speedpldi3.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=A && B==C && D==A && E==F && G==H ], cost: 1
      1: start -> lbl6 : [ A>=1 && A>=C && B==C && D==A && E==F && G==H ], cost: 1
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
      3: lbl6 -> stop : [ A>=1 && A>=C && G==H && E==F && D==A && B==C ], cost: 1
      5: lbl121 -> lbl121 : E'=1+E, [ A>=1+E && C>=1+G && A+C>=3+G && A>=E && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: 1
      4: lbl121 -> cut : [ G>=C && C>=1+G && A+C>=3+G && A>=E && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: 1
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
     10: cut -> stop : [ C>=1+A && A>=2 && E==0 && G==C && D==A && B==C ], cost: 1
      8: lbl141 -> lbl121 : E'=1+E, [ A>=1 && C>=1+G && A>=2 && C>=1+A && G>=1 && C>=G && E==0 && D==A && B==C ], cost: 1
      7: lbl141 -> cut : [ A>=2 && C>=1+A && C>=1 && G==C && E==0 && D==A && B==C ], cost: 1
      9: lbl141 -> lbl141 : E'=0, G'=1+G, [ 0>=A && C>=1+G && A>=2 && C>=1+A && G>=1 && C>=G && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1


Simplified the transitions:
  Start location: start0
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
      5: lbl121 -> lbl121 : E'=1+E, [ A>=1+E && C>=1+G && A+C>=3+G && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: 1
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
      8: lbl141 -> lbl121 : E'=1+E, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
      9: lbl141 -> lbl141 : E'=0, G'=1+G, [ 0>=A && C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1

Eliminating 1 self-loops for location lbl121
  Self-Loop 5 has the metering function: -E+A, resulting in the new transition 12.
  Removing the self-loops: 5.
Eliminating 1 self-loops for location lbl141
  Self-Loop 9 has unbounded runtime, resulting in the new transition 13.
  Removing the self-loops: 9.

Accelerated all simple loops using metering functions (where possible):
  Start location: start0
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
     12: lbl121 -> lbl121 : E'=A, [ A>=1+E && C>=1+G && A+C>=3+G && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: -E+A
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
      8: lbl141 -> lbl121 : E'=1+E, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
     13: lbl141 -> lbl141 : [ 0>=A && C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A ], cost: INF
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1


Chained simpled loops:
  Start location: start0
     14: start -> lbl121 : E'=A, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && D==A && B==C ], cost: A
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
     15: lbl141 -> lbl121 : E'=A, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C && A>=2+E && C>=1+G && A+C>=3+G && 1+E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: -E+A
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1


Eliminated locations (linear):
  Start location: start0
      6: lbl121 -> lbl121 : E'=A, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C && C>=2+G && A>=2 && C>=1+A && 1+G>=1 && 0==0 && D==A && B==C && A>=2 && C>=2+G && A+C>=4+G && 1>=1 && 1+G>=0 && C>=1+A && D==A && B==C ], cost: 1+A
     11: start0 -> lbl121 : B'=C, D'=A, E'=A, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C ], cost: 1+A

Eliminating 1 self-loops for location lbl121
  Removing the self-loops: 6.

Accelerated all simple loops using metering functions (where possible):
  Start location: start0
     16: lbl121 -> lbl121 : E'=A, G'=1+G, [ G>=0 && C>=1+A && E==A && D==A && B==C && C>=2+G && A>=2 && A+C>=4+G ], cost: 1+A
     11: start0 -> lbl121 : B'=C, D'=A, E'=A, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C ], cost: 1+A


Chained simpled loops:
  Start location: start0
     11: start0 -> lbl121 : B'=C, D'=A, E'=A, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C ], cost: 1+A
     17: start0 -> lbl121 : B'=C, D'=A, E'=A, G'=1, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C && 0>=0 && C>=1+A && A==A && A==A && C==C && C>=2 && A>=2 && A+C>=4 ], cost: 2+2*A


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
     11: start0 -> lbl121 : B'=C, D'=A, E'=A, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C ], cost: 1+A
     17: start0 -> lbl121 : B'=C, D'=A, E'=A, G'=1, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C && 0>=0 && C>=1+A && A==A && A==A && C==C && C>=2 && A>=2 && A+C>=4 ], cost: 2+2*A


Computing complexity for remaining 2 transitions.

Created initial limit problem:
-A+C (+/+!), 1 (+/+!), 1+A (+), A (+/+!), C (+/+!), -2+A+C (+/+!), -1+A (+/+!) [not solved]

applying transformation rule (C) using substitution {C==1+A}
resulting limit problem:
1 (+/+!), 1+A (+), A (+/+!), -1+A (+/+!), -1+2*A (+/+!) [not solved]

applying transformation rule (C) using substitution {C==1}
resulting limit problem:
1 (+/+!), 1+A (+), A (+/+!), -1+A (+/+!), -1+2*A (+/+!) [not solved]

applying transformation rule (C) using substitution {C==1+A}
resulting limit problem:
1 (+/+!), 1+A (+), A (+/+!), -1+A (+/+!), -1+2*A (+/+!) [not solved]

applying transformation rule (B), deleting 1 (+/+!)
resulting limit problem:
1+A (+), A (+/+!), -1+A (+/+!), -1+2*A (+/+!) [not solved]

applying transformation rule (D), replacing 1+A (+) by A (+)
resulting limit problem:
A (+), -1+A (+/+!), -1+2*A (+/+!) [not solved]

applying transformation rule (D), replacing -1+A (+/+!) by A (+)
resulting limit problem:
A (+), -1+2*A (+/+!) [not solved]

applying transformation rule (D), replacing -1+2*A (+/+!) by 2*A (+)
resulting limit problem:
2*A (+), A (+) [not solved]

applying transformation rule (A), replacing 2*A (+) by A (+) and 2 (+!) using + limit vector (+,+!)
resulting limit problem:
2 (+!), A (+) [not solved]

applying transformation rule (B), deleting 2 (+!)
resulting limit problem:
A (+) [solved]

Solution:
F / 0
A / n
C / 1+n
H / 0
Found new complexity n^1, because: Solved the initial limit problem.


The final runtime is determined by this resulting transition:
  Final Guard: A>=1 && C>=1+A && C==C && A==A && F==F && H==H && A>=2 && C>=1 && A+C>=3 && 1>=1 && 0>=0 && C>=1+A && A==A && C==C
  Final Cost:  1+n

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: n^1
  Complexity value: 1

WORST_CASE(Omega(n^1),?)
