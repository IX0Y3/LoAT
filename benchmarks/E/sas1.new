Trying to load file: sas1.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
      1: f4 -> f8 : A'=1+A, C'=0, [ B>=1+A ], cost: 1
      8: f4 -> f20 : [ A>=B ], cost: 1
      4: f8 -> f8 : A'=1+A, C'=1+C, D'=free, [ B>=1+A && 0>=1+free ], cost: 1
      5: f8 -> f8 : A'=1+A, C'=1+C, D'=free_1, [ B>=1+A && free_1>=1 ], cost: 1
      2: f8 -> f16 : D'=0, [ B>=1+A ], cost: 1
      3: f8 -> f16 : [ A>=B ], cost: 1
      6: f16 -> f4 : [ 0>=C ], cost: 1
      7: f16 -> f4 : A'=-1+A, [ C>=1 ], cost: 1


Simplified the transitions:
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
      1: f4 -> f8 : A'=1+A, C'=0, [ B>=1+A ], cost: 1
      4: f8 -> f8 : A'=1+A, C'=1+C, D'=free, [ B>=1+A && 0>=1+free ], cost: 1
      5: f8 -> f8 : A'=1+A, C'=1+C, D'=free_1, [ B>=1+A && free_1>=1 ], cost: 1
      2: f8 -> f16 : D'=0, [ B>=1+A ], cost: 1
      3: f8 -> f16 : [ A>=B ], cost: 1
      6: f16 -> f4 : [ 0>=C ], cost: 1
      7: f16 -> f4 : A'=-1+A, [ C>=1 ], cost: 1


Try instantiation
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
      1: f4 -> f8 : A'=1+A, C'=0, [ B>=1+A ], cost: 1
      9: f8 -> f8 : A'=B, C'=B-A+C, D'=free_1, [ B>=1+A ], cost: B-A
     10: f8 -> f8 : A'=B, C'=B-A+C, D'=free, [ B>=1+A ], cost: B-A
      2: f8 -> f16 : D'=0, [ B>=1+A ], cost: 1
      3: f8 -> f16 : [ A>=B ], cost: 1
      6: f16 -> f4 : [ 0>=C ], cost: 1
      7: f16 -> f4 : A'=-1+A, [ C>=1 ], cost: 1

Eliminating 2 self-loops for location f8
  Removing the self-loops: 9 10.
Adding an epsilon transition (to model nonexecution of the loops): 13.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
      1: f4 -> f8 : A'=1+A, C'=0, [ B>=1+A ], cost: 1
     11: f8 -> [5] : A'=B, C'=B-A+C, D'=free_1, [ B>=1+A ], cost: B-A
     12: f8 -> [5] : A'=B, C'=B-A+C, D'=free, [ B>=1+A ], cost: B-A
     13: f8 -> [5] : [], cost: 0
      6: f16 -> f4 : [ 0>=C ], cost: 1
      7: f16 -> f4 : A'=-1+A, [ C>=1 ], cost: 1
      2: [5] -> f16 : D'=0, [ B>=1+A ], cost: 1
      3: [5] -> f16 : [ A>=B ], cost: 1


Applied chaining over branches and pruning:
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
     14: f4 -> [5] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     15: f4 -> [5] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     16: f4 -> [5] : A'=1+A, C'=0, [ B>=1+A ], cost: 1
     17: [5] -> f4 : D'=0, [ B>=1+A && 0>=C ], cost: 2
     18: [5] -> f4 : A'=-1+A, D'=0, [ B>=1+A && C>=1 ], cost: 2
     19: [5] -> f4 : [ A>=B && 0>=C ], cost: 2
     20: [5] -> f4 : A'=-1+A, [ A>=B && C>=1 ], cost: 2


Applied chaining over branches and pruning:
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
     24: f4 -> f4 : A'=-1+B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A && B>=B && -1+B-A>=1 ], cost: 2+B-A
     28: f4 -> f4 : A'=-1+B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A && B>=B && -1+B-A>=1 ], cost: 2+B-A
     29: f4 -> f4 : A'=1+A, C'=0, D'=0, [ B>=1+A && B>=2+A && 0>=0 ], cost: 3
     30: f4 -> f4 : A'=1+A, C'=0, [ B>=1+A && 1+A>=B && 0>=0 ], cost: 3
     21: f4 -> [6] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     22: f4 -> [7] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     23: f4 -> [8] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     25: f4 -> [9] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     26: f4 -> [10] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     27: f4 -> [11] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A


Try instantiation
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
     31: f4 -> f4 : A'=B, C'=0, [ B>=1+A && A>=-1+B ], cost: 3*B-3*A
     32: f4 -> f4 : A'=-1+B, C'=0, D'=0, [ B>=1+A && B>=2+A ], cost: -3+3*B-3*A
     21: f4 -> [6] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     22: f4 -> [7] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     23: f4 -> [8] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     25: f4 -> [9] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     26: f4 -> [10] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     27: f4 -> [11] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A

Eliminating 2 self-loops for location f4
  Self-Loop 31 has the metering function: B-A, resulting in the new transition 33.
  Removing the self-loops: 31 32.
Adding an epsilon transition (to model nonexecution of the loops): 35.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f4 : A'=0, [], cost: 1
     33: f4 -> [12] : A'=B, C'=0, [ 1-B+A==0 ], cost: 0
     34: f4 -> [12] : A'=-1+B, C'=0, D'=0, [ B>=2+A ], cost: -3+3*B-3*A
     35: f4 -> [12] : [], cost: 0
     21: [12] -> [6] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     22: [12] -> [7] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     23: [12] -> [8] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     25: [12] -> [9] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     26: [12] -> [10] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     27: [12] -> [11] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A


Applied chaining over branches and pruning:
  Start location: f0
     36: f0 -> [12] : A'=B, C'=0, [ 1-B==0 ], cost: 1
     37: f0 -> [12] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     38: f0 -> [12] : A'=0, [], cost: 1
     21: [12] -> [6] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     22: [12] -> [7] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     23: [12] -> [8] : A'=B, C'=-1+B-A, D'=free_1, [ B>=1+A && B>=2+A ], cost: B-A
     25: [12] -> [9] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     26: [12] -> [10] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A
     27: [12] -> [11] : A'=B, C'=-1+B-A, D'=free, [ B>=1+A && B>=2+A ], cost: B-A


Applied chaining over branches and pruning:
  Start location: f0
     45: f0 -> [6] : A'=B, C'=-1+B, D'=free_1, [ B>=1 && B>=2 ], cost: 1+B
     46: f0 -> [7] : A'=B, C'=-1+B, D'=free_1, [ B>=1 && B>=2 ], cost: 1+B
     47: f0 -> [8] : A'=B, C'=-1+B, D'=free_1, [ B>=1 && B>=2 ], cost: 1+B
     48: f0 -> [9] : A'=B, C'=-1+B, D'=free, [ B>=1 && B>=2 ], cost: 1+B
     49: f0 -> [10] : A'=B, C'=-1+B, D'=free, [ B>=1 && B>=2 ], cost: 1+B
     50: f0 -> [11] : A'=B, C'=-1+B, D'=free, [ B>=1 && B>=2 ], cost: 1+B
     39: f0 -> [13] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     40: f0 -> [14] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     41: f0 -> [15] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     42: f0 -> [16] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     43: f0 -> [17] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     44: f0 -> [18] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     45: f0 -> [6] : A'=B, C'=-1+B, D'=free_1, [ B>=1 && B>=2 ], cost: 1+B
     46: f0 -> [7] : A'=B, C'=-1+B, D'=free_1, [ B>=1 && B>=2 ], cost: 1+B
     47: f0 -> [8] : A'=B, C'=-1+B, D'=free_1, [ B>=1 && B>=2 ], cost: 1+B
     48: f0 -> [9] : A'=B, C'=-1+B, D'=free, [ B>=1 && B>=2 ], cost: 1+B
     49: f0 -> [10] : A'=B, C'=-1+B, D'=free, [ B>=1 && B>=2 ], cost: 1+B
     50: f0 -> [11] : A'=B, C'=-1+B, D'=free, [ B>=1 && B>=2 ], cost: 1+B
     39: f0 -> [13] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     40: f0 -> [14] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     41: f0 -> [15] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     42: f0 -> [16] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     43: f0 -> [17] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B
     44: f0 -> [18] : A'=-1+B, C'=0, D'=0, [ B>=2 ], cost: -2+3*B


Computing complexity for remaining 12 transitions.

  Found configuration with infinitely models for cost: 1+B
  and guard: B>=1 && B>=2:
  B: Pos

Found new complexity n^1, because: Found infinity configuration.


The final runtime is determined by this resulting transition:
  Final Guard: B>=1 && B>=2
  Final Cost:  1+B

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: n^1
  Complexity value: 1

WORST_CASE(Omega(n^1),?)
