Trying to load file: speedpldi3.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=A && B==C && D==A && E==F && G==H ], cost: 1
      1: start -> lbl6 : [ A>=1 && A>=C && B==C && D==A && E==F && G==H ], cost: 1
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
      3: lbl6 -> stop : [ A>=1 && A>=C && G==H && E==F && D==A && B==C ], cost: 1
      5: lbl121 -> lbl121 : E'=1+E, [ A>=1+E && C>=1+G && A+C>=3+G && A>=E && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: 1
      4: lbl121 -> cut : [ G>=C && C>=1+G && A+C>=3+G && A>=E && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: 1
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
     10: cut -> stop : [ C>=1+A && A>=2 && E==0 && G==C && D==A && B==C ], cost: 1
      8: lbl141 -> lbl121 : E'=1+E, [ A>=1 && C>=1+G && A>=2 && C>=1+A && G>=1 && C>=G && E==0 && D==A && B==C ], cost: 1
      7: lbl141 -> cut : [ A>=2 && C>=1+A && C>=1 && G==C && E==0 && D==A && B==C ], cost: 1
      9: lbl141 -> lbl141 : E'=0, G'=1+G, [ 0>=A && C>=1+G && A>=2 && C>=1+A && G>=1 && C>=G && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1


Simplified the transitions:
  Start location: start0
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
      5: lbl121 -> lbl121 : E'=1+E, [ A>=1+E && C>=1+G && A+C>=3+G && E>=1 && G>=0 && C>=1+A && D==A && B==C ], cost: 1
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
      8: lbl141 -> lbl121 : E'=1+E, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
      9: lbl141 -> lbl141 : E'=0, G'=1+G, [ 0>=A && C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1


Try instantiation
  Start location: start0
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
     12: lbl121 -> lbl121 : E'=A, [ A>=1+E && E>=1 && C>=1+G && G>=0 && C>=1+A && D<=A && B<=C && D>=A && B>=C ], cost: A-E
      6: lbl121 -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1
      8: lbl141 -> lbl121 : E'=1+E, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
      9: lbl141 -> lbl141 : E'=0, G'=1+G, [ 0>=A && C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1

Eliminating 1 self-loops for location lbl121
  Removing the self-loops: 12.
Adding an epsilon transition (to model nonexecution of the loops): 14.

Try instantiation
  Start location: start0
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
     13: lbl121 -> [7] : E'=A, [ A>=1+E && E>=1 && C>=1+G && G>=0 && C>=1+A && -A+D==0 && -C+B==0 ], cost: A-E
     14: lbl121 -> [7] : [], cost: 0
      8: lbl141 -> lbl121 : E'=1+E, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1
      6: [7] -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1


Removed all Self-loops using metering functions (where possible):
  Start location: start0
      2: start -> lbl121 : E'=1, G'=0, [ A>=1 && C>=1+A && B==C && D==A && E==F && G==H ], cost: 1
     13: lbl121 -> [7] : E'=A, [ A>=1+E && E>=1 && C>=1+G && G>=0 && C>=1+A && -A+D==0 && -C+B==0 ], cost: A-E
     14: lbl121 -> [7] : [], cost: 0
      8: lbl141 -> lbl121 : E'=1+E, [ C>=1+G && A>=2 && C>=1+A && G>=1 && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, G'=H, [], cost: 1
      6: [7] -> lbl141 : E'=0, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C ], cost: 1


Applied simple chaining:
  Start location: start0
     13: lbl121 -> [7] : E'=A, [ A>=1+E && E>=1 && C>=1+G && G>=0 && C>=1+A && -A+D==0 && -C+B==0 ], cost: A-E
     14: lbl121 -> [7] : [], cost: 0
     11: start0 -> lbl121 : B'=C, D'=A, E'=1, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H ], cost: 2
      6: [7] -> lbl121 : E'=1, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C && C>=2+G && A>=2 && C>=1+A && 1+G>=1 && 0==0 && D==A && B==C ], cost: 2


Applied chaining over branches and pruning:
  Start location: start0
     15: lbl121 -> lbl121 : E'=1, G'=1+G, [ A>=1+E && E>=1 && C>=1+G && G>=0 && C>=1+A && -A+D==0 && -C+B==0 && C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && A==A && D==A && B==C && C>=2+G && A>=2 && C>=1+A && 1+G>=1 && 0==0 && D==A && B==C ], cost: 2+A-E
     16: lbl121 -> lbl121 : E'=1, G'=1+G, [ C>=1+G && A+C>=3+G && A>=1 && G>=0 && C>=1+A && E==A && D==A && B==C && C>=2+G && A>=2 && C>=1+A && 1+G>=1 && 0==0 && D==A && B==C ], cost: 2
     11: start0 -> lbl121 : B'=C, D'=A, E'=1, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H ], cost: 2


Try instantiation
  Start location: start0
     11: start0 -> lbl121 : B'=C, D'=A, E'=1, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H ], cost: 2


Removed all Self-loops using metering functions (where possible):
  Start location: start0
     11: start0 -> lbl121 : B'=C, D'=A, E'=1, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H ], cost: 2


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
     11: start0 -> lbl121 : B'=C, D'=A, E'=1, G'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && H==H ], cost: 2


Computing complexity for remaining 1 transitions.

Found new complexity const, because: const cost.


The final runtime is determined by this resulting transition:
  Final Guard: A>=1 && C>=1+A && C==C && A==A && F==F && H==H
  Final Cost:  2

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
