Trying to load file: ex04.koat

Initial Control flow graph problem:
  Start location: evalfstart
      0: evalfstart -> evalfentryin : [], cost: 1
      1: evalfentryin -> evalfbb7in : A'=0, [], cost: 1
      2: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=0 && 0>=B^3 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      5: evalfbb7in -> evalfreturnin : [ B^3>=0 && 0>=B^3 && A>=0 ], cost: 1
      6: evalfbb7in -> evalfreturnin : [ B^3>=1 && free_2>=0 && B^3>=2*free_2 && 1+2*free_2>=B^3 && A>=free_2 ], cost: 1
      7: evalfbb7in -> evalfreturnin : [ 0>=1+B^3 && 0>=free_3 && A>=free_3 && 2*free_3>=B^3 && 1+B^3>=2*free_3 ], cost: 1
      8: evalfbb5in -> evalfbb3in : D'=0, [ B>=1+C ], cost: 1
      9: evalfbb5in -> evalfbb6in : [ C>=B ], cost: 1
     15: evalfreturnin -> evalfstop : [], cost: 1
     10: evalfbb3in -> evalfbb2in : [ C>=1+D ], cost: 1
     11: evalfbb3in -> evalfbb4in : [ D>=C ], cost: 1
     14: evalfbb6in -> evalfbb7in : A'=1+A, [], cost: 1
     12: evalfbb2in -> evalfbb3in : D'=1+D, [], cost: 1
     13: evalfbb4in -> evalfbb5in : C'=1+C, [], cost: 1


Simplified the transitions:
  Start location: evalfstart
      0: evalfstart -> evalfentryin : [], cost: 1
      1: evalfentryin -> evalfbb7in : A'=0, [], cost: 1
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      8: evalfbb5in -> evalfbb3in : D'=0, [ B>=1+C ], cost: 1
      9: evalfbb5in -> evalfbb6in : [ C>=B ], cost: 1
     10: evalfbb3in -> evalfbb2in : [ C>=1+D ], cost: 1
     11: evalfbb3in -> evalfbb4in : [ D>=C ], cost: 1
     14: evalfbb6in -> evalfbb7in : A'=1+A, [], cost: 1
     12: evalfbb2in -> evalfbb3in : D'=1+D, [], cost: 1
     13: evalfbb4in -> evalfbb5in : C'=1+C, [], cost: 1


Eliminated locations (linear):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      9: evalfbb5in -> evalfbb7in : A'=1+A, [ C>=B ], cost: 2
      8: evalfbb5in -> evalfbb3in : D'=0, [ B>=1+C ], cost: 1
     11: evalfbb3in -> evalfbb5in : C'=1+C, [ D>=C ], cost: 2
     10: evalfbb3in -> evalfbb3in : D'=1+D, [ C>=1+D ], cost: 2

Eliminating 1 self-loops for location evalfbb3in
  Self-Loop 10 has the metering function: -D+C, resulting in the new transition 16.
  Removing the self-loops: 10.

Accelerated all simple loops using metering functions (where possible):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      9: evalfbb5in -> evalfbb7in : A'=1+A, [ C>=B ], cost: 2
      8: evalfbb5in -> evalfbb3in : D'=0, [ B>=1+C ], cost: 1
     11: evalfbb3in -> evalfbb5in : C'=1+C, [ D>=C ], cost: 2
     16: evalfbb3in -> evalfbb3in : D'=C, [ C>=1+D ], cost: -2*D+2*C


Chained simpled loops:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      9: evalfbb5in -> evalfbb7in : A'=1+A, [ C>=B ], cost: 2
     17: evalfbb5in -> evalfbb3in : D'=C, [ B>=1+C && C>=1 ], cost: 1+2*C
     11: evalfbb3in -> evalfbb5in : C'=1+C, [ D>=C ], cost: 2


Eliminated locations (linear):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      9: evalfbb5in -> evalfbb7in : A'=1+A, [ C>=B ], cost: 2
     17: evalfbb5in -> evalfbb5in : C'=1+C, D'=C, [ B>=1+C && C>=1 && C>=C ], cost: 3+2*C

Eliminating 1 self-loops for location evalfbb5in
  Self-Loop 17 has the metering function: B-C, resulting in the new transition 18.
  Removing the self-loops: 17.

Accelerated all simple loops using metering functions (where possible):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      9: evalfbb5in -> evalfbb7in : A'=1+A, [ C>=B ], cost: 2
     18: evalfbb5in -> evalfbb5in : C'=B, D'=-1+B, [ B>=1+C && C>=1 ], cost: (B-C)^2+2*B-2*C+2*C*(B-C)


Chained simpled loops:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
      2: evalfbb7in -> evalfbb5in : C'=0, [ -B^3==0 && 0>=1+A ], cost: 1
      3: evalfbb7in -> evalfbb5in : C'=0, [ B^3>=1 && free>=0 && B^3>=2*free && 1+2*free>=B^3 && free>=1+A ], cost: 1
      4: evalfbb7in -> evalfbb5in : C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 ], cost: 1
      9: evalfbb5in -> evalfbb7in : A'=1+A, [ C>=B ], cost: 2


Eliminated locations (branches):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
     19: evalfbb7in -> evalfbb7in : A'=1+A, C'=0, [ -B^3==0 && 0>=1+A && 0>=B ], cost: 3
     20: evalfbb7in -> evalfbb7in : A'=1+A, C'=0, [ 0>=1+B^3 && 0>=free_1 && free_1>=1+A && 2*free_1>=B^3 && 1+B^3>=2*free_1 && 0>=B ], cost: 3

Eliminating 2 self-loops for location evalfbb7in
  Self-Loop 19 has the metering function: -A, resulting in the new transition 21.
  Self-Loop 20 has the metering function: -A, resulting in the new transition 22.
  Removing the self-loops: 19 20.

Accelerated all simple loops using metering functions (where possible):
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2
     21: evalfbb7in -> evalfbb7in : A'=0, C'=0, [ -B^3==0 && 0>=1+A ], cost: -3*A
     22: evalfbb7in -> evalfbb7in : A'=0, C'=0, [ 0>=1+B^3 && 0>=0 && 0>=1+A && 0>=B^3 && 1+B^3>=0 ], cost: -3*A


Chained simpled loops:
  Start location: evalfstart
      0: evalfstart -> evalfbb7in : A'=0, [], cost: 2


Pruned:
  Start location: evalfstart
    <empty>


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: evalfstart
    <empty>


Computing complexity for remaining 0 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
