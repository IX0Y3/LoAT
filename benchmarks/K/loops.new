Trying to load file: loops.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : D'=F, [ 0>=1+A && B==C && D==E && F==A ], cost: 1
      1: start -> lbl121 : B'=1, D'=-1+F, [ A>=0 && 1>=A && B==C && D==E && F==A ], cost: 1
      2: start -> lbl101 : B'=2, D'=F, [ A>=2 && B==C && D==E && F==A ], cost: 1
      3: lbl121 -> stop : [ A>=0 && B>=0 && B>=1 && 1+D==0 && F==A ], cost: 1
      4: lbl121 -> lbl121 : B'=1, D'=-1+D, [ D>=0 && 1>=D && A>=1+D && B>=1+D && B>=1 && 1+D>=0 && F==A ], cost: 1
      5: lbl121 -> lbl101 : B'=2, [ D>=2 && A>=1+D && B>=1+D && B>=1 && 1+D>=0 && F==A ], cost: 1
      7: lbl101 -> lbl121 : D'=-1+D, [ B>=D && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      6: lbl101 -> lbl101 : B'=2*B, [ D>=1+B && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      8: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1


Simplified the transitions:
  Start location: start0
      1: start -> lbl121 : B'=1, D'=-1+F, [ A>=0 && 1>=A && B==C && D==E && F==A ], cost: 1
      2: start -> lbl101 : B'=2, D'=F, [ A>=2 && B==C && D==E && F==A ], cost: 1
      4: lbl121 -> lbl121 : B'=1, D'=-1+D, [ D>=0 && 1>=D && A>=1+D && B>=1+D && B>=1 && F==A ], cost: 1
      5: lbl121 -> lbl101 : B'=2, [ D>=2 && A>=1+D && B>=1+D && B>=1 && F==A ], cost: 1
      7: lbl101 -> lbl121 : D'=-1+D, [ B>=D && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      6: lbl101 -> lbl101 : B'=2*B, [ D>=1+B && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      8: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1


Try instantiation
  Start location: start0
      1: start -> lbl121 : B'=1, D'=-1+F, [ A>=0 && 1>=A && B==C && D==E && F==A ], cost: 1
      2: start -> lbl101 : B'=2, D'=F, [ A>=2 && B==C && D==E && F==A ], cost: 1
      9: lbl121 -> lbl121 : B'=1, D'=-1, [ D>=0 && 1>=D && A>=1+D && B>=1+D && F<=A && F>=A ], cost: 1+D
      5: lbl121 -> lbl101 : B'=2, [ D>=2 && A>=1+D && B>=1+D && B>=1 && F==A ], cost: 1
      7: lbl101 -> lbl121 : D'=-1+D, [ B>=D && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      6: lbl101 -> lbl101 : B'=2*B, [ D>=1+B && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      8: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1

Eliminating 1 self-loops for location lbl121
  Self-Loop 9 has the metering function: meter, resulting in the new transition 10.
  Removing the self-loops: 9.

Try instantiation
  Start location: start0
      1: start -> lbl121 : B'=1, D'=-1+F, [ A>=0 && 1>=A && B==C && D==E && F==A ], cost: 1
      2: start -> lbl101 : B'=2, D'=F, [ A>=2 && B==C && D==E && F==A ], cost: 1
     10: lbl121 -> [5] : B'=1, D'=-1, [ D>=0 && 1>=D && A>=1+D && B>=1+D && F-A==0 && 2*meter==D ], cost: 0
      7: lbl101 -> lbl121 : D'=-1+D, [ B>=D && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
     11: lbl101 -> lbl101 : B'=2*B, [ D>=1+B && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
      8: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1
      5: [5] -> lbl101 : B'=2, [ D>=2 && A>=1+D && B>=1+D && B>=1 && F==A ], cost: 1

Eliminating 1 self-loops for location lbl101
  Removing the self-loops: 11.
Adding an epsilon transition (to model nonexecution of the loops): 13.

Removed all Self-loops using metering functions (where possible):
  Start location: start0
      1: start -> lbl121 : B'=1, D'=-1+F, [ A>=0 && 1>=A && B==C && D==E && F==A ], cost: 1
      2: start -> lbl101 : B'=2, D'=F, [ A>=2 && B==C && D==E && F==A ], cost: 1
     10: lbl121 -> [5] : B'=1, D'=-1, [ D>=0 && 1>=D && A>=1+D && B>=1+D && F-A==0 && 2*meter==D ], cost: 0
     12: lbl101 -> [6] : B'=2*B, [ D>=1+B && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1
     13: lbl101 -> [6] : [], cost: 0
      8: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1
      5: [5] -> lbl101 : B'=2, [ D>=2 && A>=1+D && B>=1+D && B>=1 && F==A ], cost: 1
      7: [6] -> lbl121 : D'=-1+D, [ B>=D && B>=2 && 2*D>=2+B && A>=D && F==A ], cost: 1


Applied chaining over branches and pruning:
  Start location: start0
    <empty>


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
    <empty>


Computing complexity for remaining 0 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
