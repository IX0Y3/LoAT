Trying to load file: ex18.koat

Initial Control flow graph problem:
  Start location: f0
      0: f15 -> f16 : [ A>=1+B ], cost: 1
      1: f15 -> f16 : [ B>=1+A ], cost: 1
      8: f15 -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
      5: f16 -> f15 : B'=1+B, [], cost: 1
      9: f16 -> f23 : B'=-1+B, E'=0, [], cost: 1
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
      2: f0 -> f7 : A'=free, C'=free, [ 0>=free ], cost: 1
      3: f0 -> f7 : A'=free_1, C'=free_1, [ free_1>=101 ], cost: 1
      7: f23 -> f7 : [ E>=B ], cost: 1
      6: f23 -> f23 : E'=1+E, [ B>=1+E ], cost: 1


Simplified the transitions:
  Start location: f0
      0: f15 -> f16 : [ A>=1+B ], cost: 1
      1: f15 -> f16 : [ B>=1+A ], cost: 1
      8: f15 -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
      5: f16 -> f15 : B'=1+B, [], cost: 1
      9: f16 -> f23 : B'=-1+B, E'=0, [], cost: 1
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
      6: f23 -> f23 : E'=1+E, [ B>=1+E ], cost: 1


Try instantiation
  Start location: f0
      0: f15 -> f16 : [ A>=1+B ], cost: 1
      1: f15 -> f16 : [ B>=1+A ], cost: 1
      8: f15 -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
      5: f16 -> f15 : B'=1+B, [], cost: 1
      9: f16 -> f23 : B'=-1+B, E'=0, [], cost: 1
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
     10: f23 -> f23 : E'=B, [ B>=1+E ], cost: -E+B

Eliminating 1 self-loops for location f23
  Removing the self-loops: 10.
Adding an epsilon transition (to model nonexecution of the loops): 12.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f15 -> f16 : [ A>=1+B ], cost: 1
      1: f15 -> f16 : [ B>=1+A ], cost: 1
      8: f15 -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
      5: f16 -> f15 : B'=1+B, [], cost: 1
      9: f16 -> f23 : B'=-1+B, E'=0, [], cost: 1
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
     11: f23 -> [5] : E'=B, [ B>=1+E ], cost: -E+B
     12: f23 -> [5] : [], cost: 0


Applied chaining over branches and pruning:
  Start location: f0
     13: f15 -> f15 : B'=1+B, [ A>=1+B ], cost: 2
     15: f15 -> f15 : B'=1+B, [ B>=1+A ], cost: 2
      8: f15 -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
     14: f15 -> f23 : B'=-1+B, E'=0, [ A>=1+B ], cost: 2
     16: f15 -> f23 : B'=-1+B, E'=0, [ B>=1+A ], cost: 2
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
     11: f23 -> [5] : E'=B, [ B>=1+E ], cost: -E+B


Try instantiation
  Start location: f0
     17: f15 -> f15 : [ B>=A && B>=1+A ], cost: INF
     18: f15 -> f15 : B'=A, [ A>=1+B ], cost: 2*A-2*B
      8: f15 -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
     14: f15 -> f23 : B'=-1+B, E'=0, [ A>=1+B ], cost: 2
     16: f15 -> f23 : B'=-1+B, E'=0, [ B>=1+A ], cost: 2
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
     11: f23 -> [5] : E'=B, [ B>=1+E ], cost: -E+B

Eliminating 2 self-loops for location f15
  Removing the self-loops: 17 18.
Adding an epsilon transition (to model nonexecution of the loops): 21.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
     19: f15 -> [6] : [ B>=A && B>=1+A ], cost: INF
     20: f15 -> [6] : B'=A, [ A>=1+B ], cost: 2*A-2*B
     21: f15 -> [6] : [], cost: 0
      4: f0 -> f15 : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
     11: f23 -> [5] : E'=B, [ B>=1+E ], cost: -E+B
      8: [6] -> f23 : B'=-1+A, E'=0, [ A==B ], cost: 1
     14: [6] -> f23 : B'=-1+B, E'=0, [ A>=1+B ], cost: 2
     16: [6] -> f23 : B'=-1+B, E'=0, [ B>=1+A ], cost: 2


Applied chaining over branches and pruning:
  Start location: f0
     22: f0 -> [6] : A'=free_2, B'=free_2, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 && free_2>=1 ], cost: 1+2*free_2
     23: f0 -> [6] : A'=free_2, B'=0, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 ], cost: 1
     24: [6] -> [5] : B'=-1+A, E'=-1+A, [ A==B && -1+A>=1 ], cost: A
     25: [6] -> [5] : B'=-1+B, E'=-1+B, [ A>=1+B && -1+B>=1 ], cost: 1+B
     26: [6] -> [5] : B'=-1+B, E'=-1+B, [ B>=1+A && -1+B>=1 ], cost: 1+B


Applied chaining over branches and pruning:
  Start location: f0
     27: f0 -> [5] : A'=free_2, B'=-1+free_2, C'=free_2, D'=free_3, E'=-1+free_2, [ 100>=free_2 && free_2>=1 && free_2>=1 && free_2==free_2 && -1+free_2>=1 ], cost: 1+3*free_2
     28: f0 -> [7] : A'=free_2, B'=free_2, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 && free_2>=1 ], cost: 1+2*free_2
     29: f0 -> [8] : A'=free_2, B'=free_2, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 && free_2>=1 ], cost: 1+2*free_2


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     27: f0 -> [5] : A'=free_2, B'=-1+free_2, C'=free_2, D'=free_3, E'=-1+free_2, [ 100>=free_2 && free_2>=1 && free_2>=1 && free_2==free_2 && -1+free_2>=1 ], cost: 1+3*free_2
     28: f0 -> [7] : A'=free_2, B'=free_2, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 && free_2>=1 ], cost: 1+2*free_2
     29: f0 -> [8] : A'=free_2, B'=free_2, C'=free_2, D'=free_3, [ 100>=free_2 && free_2>=1 && free_2>=1 ], cost: 1+2*free_2


Computing complexity for remaining 3 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
