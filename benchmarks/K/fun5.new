Trying to load file: fun5.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f1 : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 ], cost: 1
      1: f1 -> f2 : F'=1+D, [ 1+B>=2*D ], cost: 1
      2: f1 -> f2 : F'=-1+D, [ 2*D>=4+B ], cost: 1
      3: f1 -> f2 : F'=D, [ 2+B==2*D ], cost: 1
      4: f1 -> f2 : F'=D, [ 3+B==2*D ], cost: 1
      5: f2 -> f3 : G'=1+E, [ D+A>=1+2*E ], cost: 1
      6: f2 -> f3 : G'=-1+E, [ 2*E>=2+D+A ], cost: 1
      7: f2 -> f3 : G'=E, [ D+A==2*E ], cost: 1
      8: f2 -> f3 : G'=E, [ 1+D+A==2*E ], cost: 1
      9: f3 -> f1 : D'=F, E'=G, [ D>=1+F ], cost: 1
     10: f3 -> f1 : D'=F, E'=G, [ F>=1+D ], cost: 1
     11: f3 -> f1 : D'=F, E'=G, [ E>=1+G ], cost: 1
     12: f3 -> f1 : D'=F, E'=G, [ G>=1+E ], cost: 1


Applied chaining over branches and pruning:
  Start location: f0
      0: f0 -> f1 : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 ], cost: 1
     13: f1 -> f3 : F'=1+D, G'=1+E, [ 1+B>=2*D && D+A>=1+2*E ], cost: 2
     14: f1 -> f3 : F'=1+D, G'=-1+E, [ 1+B>=2*D && 2*E>=2+D+A ], cost: 2
     16: f1 -> f3 : F'=1+D, G'=E, [ 1+B>=2*D && 1+D+A==2*E ], cost: 2
     20: f1 -> f3 : F'=-1+D, G'=E, [ 2*D>=4+B && 1+D+A==2*E ], cost: 2
     22: f1 -> f3 : F'=D, G'=-1+E, [ 2+B==2*D && 2*E>=2+D+A ], cost: 2
      9: f3 -> f1 : D'=F, E'=G, [ D>=1+F ], cost: 1
     10: f3 -> f1 : D'=F, E'=G, [ F>=1+D ], cost: 1
     11: f3 -> f1 : D'=F, E'=G, [ E>=1+G ], cost: 1
     12: f3 -> f1 : D'=F, E'=G, [ G>=1+E ], cost: 1


Applied chaining over branches and pruning:
  Start location: f0
      0: f0 -> f1 : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 ], cost: 1
     29: f1 -> f1 : D'=1+D, E'=1+E, F'=1+D, G'=1+E, [ 1+B>=2*D && D+A>=1+2*E && 1+D>=1+D ], cost: 3
     30: f1 -> f1 : D'=1+D, E'=1+E, F'=1+D, G'=1+E, [ 1+B>=2*D && D+A>=1+2*E && 1+E>=1+E ], cost: 3
     31: f1 -> f1 : D'=1+D, E'=-1+E, F'=1+D, G'=-1+E, [ 1+B>=2*D && 2*E>=2+D+A && 1+D>=1+D ], cost: 3
     32: f1 -> f1 : D'=1+D, E'=-1+E, F'=1+D, G'=-1+E, [ 1+B>=2*D && 2*E>=2+D+A && E>=E ], cost: 3
     33: f1 -> f1 : D'=1+D, E'=E, F'=1+D, G'=E, [ 1+B>=2*D && 1+D+A==2*E && 1+D>=1+D ], cost: 3


Try instantiation
  Start location: f0
      0: f0 -> f1 : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 ], cost: 1
     36: f1 -> f1 : D'=2*E-A, E'=E, F'=2*E-A, G'=E, [ D+A<=-1+2*E && D+A>=-1+2*E && B>=-3+4*E-2*A ], cost: -3*D+6*E-3*A
     37: f1 -> f1 : D'=-1+2*E-A, E'=1+D-E+A, F'=-1+2*E-A, G'=1+D-E+A, [ 2*E>=2+D+A && B>=-5+4*E-2*A && 2*D-2*E+2*A>=-4+2*E ], cost: -3-3*D+6*E-3*A
     38: f1 -> f1 : D'=-1+2*E-A, E'=1+D-E+A, F'=-1+2*E-A, G'=1+D-E+A, [ 2*E>=2+D+A && B>=-5+4*E-2*A && 2*D-2*E+2*A>=-4+2*E ], cost: -3-3*D+6*E-3*A
     39: f1 -> f1 : [ B>=1+2*D && D+A>=2+2*E ], cost: INF
     40: f1 -> f1 : [ B>=1+2*D && D+A>=2+2*E ], cost: INF

Eliminating 5 self-loops for location f1
  Self-Loop 36 has the metering function: -D+2*E-A, resulting in the new transition 41.
  Self-Loop 37 has the metering function: meter, resulting in the new transition 42.
  Self-Loop 38 has the metering function: meter_1, resulting in the new transition 43.
  Removing the self-loops: 36 37 38 39 40.
Removing duplicate transition: 44.

Removed all Self-loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f1 : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 ], cost: 1
     41: f1 -> [4] : D'=2*E-A, F'=2*E-A, G'=E, [ 1+D-2*E+A==0 && B>=-3+4*E-2*A ], cost: 0
     42: f1 -> [4] : D'=1+2^meter*D-2^meter*A-2^meter+A, E'=1+A, F'=1+2^meter*D-2^meter*A-2^meter+A, G'=1+A, [ 2*E>=2+D+A && B>=-5+4*E-2*A && 2*D-2*E+2*A>=-4+2*E && 3*meter==-1-D+2*E-A && D==E && D==F && D==G ], cost: -3-3*2^meter*D+3*2^meter*A+3*2^meter+3*D-3*A
     43: f1 -> [4] : D'=1-2^meter_1*A-2^meter_1+A+D*2^meter_1, E'=1+A, F'=1-2^meter_1*A-2^meter_1+A+D*2^meter_1, G'=1+A, [ 2*E>=2+D+A && B>=-5+4*E-2*A && 2*D-2*E+2*A>=-4+2*E && 3*meter_1==-1-D+2*E-A && D==E && D==F && D==G ], cost: -3+3*D+3*2^meter_1*A+3*2^meter_1-3*A-3*D*2^meter_1
     45: f1 -> [4] : [ B>=1+2*D && D+A>=2+2*E ], cost: INF


Applied chaining over branches and pruning:
  Start location: f0
     47: f0 -> [4] : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 && B>=1+2*D && D+A>=2+2*E ], cost: INF


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
     47: f0 -> [4] : [ A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 && B>=1+2*D && D+A>=2+2*E ], cost: INF


Computing complexity for remaining 1 transitions.

Found new complexity INF, because: INF sat.


The final runtime is determined by this resulting transition:
  Final Guard: A>=0 && 3>=A && B>=0 && 3>=B && 3>=C && D>=0 && 3>=E && E>=0 && B>=1+2*D && D+A>=2+2*E
  Final Cost:  INF

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: INF
  Complexity value: INF

WORST_CASE(INF,?)
