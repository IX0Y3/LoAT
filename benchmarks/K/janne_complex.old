Trying to load file: janne_complex.koat

Initial Control flow graph problem:
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
      1: f8 -> f10 : [ 29>=D ], cost: 1
      8: f8 -> f28 : C'=1, F'=1, [ D>=30 ], cost: 1
      7: f10 -> f8 : D'=2+D, E'=-10+E, [ E>=D ], cost: 1
      2: f10 -> f14 : E'=free, [ D>=1+E && E>=6 ], cost: 1
      3: f10 -> f14 : E'=2+E, [ D>=1+E && 5>=E ], cost: 1
      4: f14 -> f10 : D'=10+D, [ 12>=E && E>=10 ], cost: 1
      5: f14 -> f10 : D'=1+D, [ E>=13 ], cost: 1
      6: f14 -> f10 : D'=1+D, [ 9>=E ], cost: 1


Simplified the transitions:
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
      1: f8 -> f10 : [ 29>=D ], cost: 1
      7: f10 -> f8 : D'=2+D, E'=-10+E, [ E>=D ], cost: 1
      2: f10 -> f14 : E'=free, [ D>=1+E && E>=6 ], cost: 1
      3: f10 -> f14 : E'=2+E, [ D>=1+E && 5>=E ], cost: 1
      4: f14 -> f10 : D'=10+D, [ 12>=E && E>=10 ], cost: 1
      5: f14 -> f10 : D'=1+D, [ E>=13 ], cost: 1
      6: f14 -> f10 : D'=1+D, [ 9>=E ], cost: 1


Eliminated locations (branches):
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
      1: f8 -> f10 : [ 29>=D ], cost: 1
      7: f10 -> f8 : D'=2+D, E'=-10+E, [ E>=D ], cost: 1
      9: f10 -> f10 : D'=10+D, E'=free, [ D>=1+E && E>=6 && 12>=free && free>=10 ], cost: 2
     10: f10 -> f10 : D'=1+D, E'=free, [ D>=1+E && E>=6 && free>=13 ], cost: 2
     11: f10 -> f10 : D'=1+D, E'=free, [ D>=1+E && E>=6 && 9>=free ], cost: 2
     12: f10 -> f10 : D'=1+D, E'=2+E, [ D>=1+E && 5>=E && 9>=2+E ], cost: 2

Eliminating 4 self-loops for location f10
  Self-Loop 10 has the metering function: meter, resulting in the new transition 14.
  Self-Loop 11 has the metering function: meter_1, resulting in the new transition 15.
  Self-Loop 17 has unbounded runtime, resulting in the new transition 19.
  Found this metering function when nesting loops: meter_2,
  Found this metering function when nesting loops: meter_3,
  Found this metering function when nesting loops: meter_4,
  Found this metering function when nesting loops: meter_5,
  Removing the self-loops: 9 10 11 12 16 17.

Accelerated all simple loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
      1: f8 -> f10 : [ 29>=D ], cost: 1
      7: f10 -> f8 : D'=2+D, E'=-10+E, [ E>=D ], cost: 1
     13: f10 -> f10 : D'=10+D, E'=free, [ D>=1+E && E>=6 && 12>=free && free>=10 ], cost: 2
     14: f10 -> f10 : D'=D+meter, E'=13, [ D>=1+E && E>=6 && 13>=13 && 6*meter==D-E ], cost: 2*meter
     15: f10 -> f10 : D'=D+meter_1, E'=9, [ D>=1+E && E>=6 && 9>=9 && 2*meter_1==D-E ], cost: 2*meter_1
     18: f10 -> f10 : D'=1+D, E'=2+E, [ D>=1+E && 5>=E ], cost: 2
     19: f10 -> f10 : [ D>=1+E && 5>=E && E>D ], cost: INF


Chained simpled loops:
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
      1: f8 -> f10 : [ 29>=D ], cost: 1
     20: f8 -> f10 : D'=10+D, E'=free, [ 29>=D && D>=1+E && E>=6 && 12>=free && free>=10 ], cost: 3
     21: f8 -> f10 : D'=D+meter, E'=13, [ 29>=D && D>=1+E && E>=6 && 13>=13 && 6*meter==D-E ], cost: 1+2*meter
     22: f8 -> f10 : D'=D+meter_1, E'=9, [ 29>=D && D>=1+E && E>=6 && 9>=9 && 2*meter_1==D-E ], cost: 1+2*meter_1
     23: f8 -> f10 : D'=1+D, E'=2+E, [ 29>=D && D>=1+E && 5>=E ], cost: 3
      7: f10 -> f8 : D'=2+D, E'=-10+E, [ E>=D ], cost: 1


Eliminated locations (branches):
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
     24: f8 -> f8 : D'=2+D, E'=-10+E, [ 29>=D && E>=D ], cost: 2
     25: f8 -> f8 : D'=2+D+meter, E'=3, [ 29>=D && D>=1+E && E>=6 && 13>=13 && 6*meter==D-E && 13>=D+meter ], cost: 2+2*meter
     26: f8 -> f8 : D'=2+D+meter_1, E'=-1, [ 29>=D && D>=1+E && E>=6 && 9>=9 && 2*meter_1==D-E && 9>=D+meter_1 ], cost: 2+2*meter_1
     27: f8 -> f8 : D'=3+D, E'=-8+E, [ 29>=D && D>=1+E && 5>=E && 2+E>=1+D ], cost: 4

Eliminating 4 self-loops for location f8
  Self-Loop 27 has the metering function: meter_6, resulting in the new transition 33.
  Self-Loop 28 has unbounded runtime, resulting in the new transition 34.
  Removing the self-loops: 24 25 26 27 28 29.

Accelerated all simple loops using metering functions (where possible):
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
     30: f8 -> f8 : D'=2+D, E'=-10+E, [ 29>=D && E>=D ], cost: 2
     31: f8 -> f8 : D'=2+D+meter, E'=3, [ 29>=D && D>=1+E && E>=6 && 6*meter==D-E && 13>=D+meter ], cost: 2+2*meter
     32: f8 -> f8 : D'=2+D+meter_1, E'=-1, [ 29>=D && D>=1+E && E>=6 && 2*meter_1==D-E && 9>=D+meter_1 ], cost: 2+2*meter_1
     33: f8 -> f8 : D'=D+3*meter_6, E'=E-8*meter_6, [ 29>=D && 1-D+E==0 && 5>=E && 11*meter_6==2-D+E ], cost: 4*meter_6
     34: f8 -> f8 : [ 29>=D && E>=D && D>E ], cost: INF


Chained simpled loops:
  Start location: f0
      0: f0 -> f8 : A'=1, B'=1, C'=0, D'=1, E'=1, [], cost: 1
     35: f0 -> f8 : A'=1, B'=1, C'=0, D'=3, E'=-9, [ 29>=1 && 1>=1 ], cost: 3


Pruned:
  Start location: f0
    <empty>


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f0
    <empty>


Computing complexity for remaining 0 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
