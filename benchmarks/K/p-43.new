Trying to load file: p-43.koat

Initial Control flow graph problem:
  Start location: f2
      0: f2 -> f300 : [], cost: 1
      1: f300 -> f300 : A'=-1+B, B'=-1+B, C'=free, [ A>=1 && B>=1 && free>=1 && A+B>=1 ], cost: 1
      2: f300 -> f300 : A'=-1+B, B'=-1+B, C'=free_1, [ A>=1 && B>=1 && 0>=1+free_1 && A+B>=1 ], cost: 1
      3: f300 -> f300 : A'=-1+A, B'=-2+A, C'=0, [ A>=1 && A+B>=1 && B>=1 ], cost: 1
      4: f300 -> f1 : D'=free_2, [ A>=1 && 0>=A+B && B>=1 ], cost: 1
      5: f300 -> f1 : D'=free_3, [ B>=1 && 0>=A ], cost: 1
      6: f300 -> f1 : D'=free_4, [ 0>=B ], cost: 1


Simplified the transitions:
  Start location: f2
      0: f2 -> f300 : [], cost: 1
      1: f300 -> f300 : A'=-1+B, B'=-1+B, C'=free, [ A>=1 && B>=1 && free>=1 && A+B>=1 ], cost: 1
      2: f300 -> f300 : A'=-1+B, B'=-1+B, C'=free_1, [ A>=1 && B>=1 && 0>=1+free_1 && A+B>=1 ], cost: 1
      3: f300 -> f300 : A'=-1+A, B'=-2+A, C'=0, [ A>=1 && A+B>=1 && B>=1 ], cost: 1


Try instantiation
  Start location: f2
      0: f2 -> f300 : [], cost: 1
      7: f300 -> f300 : A'=2, B'=1, C'=0, [ A+B>=1 && B>=1 && A>=1 ], cost: -2+A
      8: f300 -> f300 : A'=1, B'=1, C'=free_1, [ A+B>=1 && A>=1 && B>=1 ], cost: -1+B
      9: f300 -> f300 : A'=0, B'=0, C'=free_1, [ A+B>=1 && A>=1 && B>=1 ], cost: B
     10: f300 -> f300 : A'=1-B, B'=1-B, C'=free_1, [ B<=1 && A>=1 && B>=1 && A+B>=1 ], cost: -1+2*B
     11: f300 -> f300 : A'=1, B'=1, C'=free, [ A+B>=1 && A>=1 && B>=1 ], cost: -1+B
     12: f300 -> f300 : A'=0, B'=0, C'=free, [ A+B>=1 && A>=1 && B>=1 ], cost: B
     13: f300 -> f300 : A'=1-B, B'=1-B, C'=free, [ B<=1 && A>=1 && B>=1 && A+B>=1 ], cost: -1+2*B

Eliminating 7 self-loops for location f300
  Self-Loop 7 has unbounded runtime, resulting in the new transition 14.
  Self-Loop 8 has unbounded runtime, resulting in the new transition 15.
  Self-Loop 10 has the metering function: -1+B, resulting in the new transition 17.
  Self-Loop 11 has unbounded runtime, resulting in the new transition 18.
  Self-Loop 13 has the metering function: -1+B, resulting in the new transition 20.
  Removing the self-loops: 7 8 9 10 11 12 13.
Adding an epsilon transition (to model nonexecution of the loops): 21.
Removing duplicate transition: 15.

Removed all Self-loops using metering functions (where possible):
  Start location: f2
      0: f2 -> f300 : [], cost: 1
     14: f300 -> [3] : [ A+B>=1 && B>=1 && A>=1 ], cost: INF
     16: f300 -> [3] : A'=0, B'=0, C'=free_1, [ A+B>=1 && A>=1 && B>=1 ], cost: B
     17: f300 -> [3] : A'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), B'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), C'=free_1, [ -1+B==0 && A>=1 && A+B>=1 ], cost: -1/2+(-1)^B*B+1/2*(-1)^(-1+B)+B
     18: f300 -> [3] : [ A+B>=1 && A>=1 && B>=1 ], cost: INF
     19: f300 -> [3] : A'=0, B'=0, C'=free, [ A+B>=1 && A>=1 && B>=1 ], cost: B
     20: f300 -> [3] : A'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), B'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), C'=free, [ -1+B==0 && A>=1 && A+B>=1 ], cost: -1/2+(-1)^B*B+1/2*(-1)^(-1+B)+B
     21: f300 -> [3] : [], cost: 0


Applied chaining over branches and pruning:
  Start location: f2
     22: f2 -> [3] : [ A+B>=1 && B>=1 && A>=1 ], cost: INF
     23: f2 -> [3] : A'=0, B'=0, C'=free_1, [ A+B>=1 && A>=1 && B>=1 ], cost: 1+B
     25: f2 -> [3] : [ A+B>=1 && A>=1 && B>=1 ], cost: INF
     26: f2 -> [3] : A'=0, B'=0, C'=free, [ A+B>=1 && A>=1 && B>=1 ], cost: 1+B
     27: f2 -> [3] : A'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), B'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), C'=free, [ -1+B==0 && A>=1 && A+B>=1 ], cost: 1/2+(-1)^B*B+1/2*(-1)^(-1+B)+B


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: f2
     22: f2 -> [3] : [ A+B>=1 && B>=1 && A>=1 ], cost: INF
     23: f2 -> [3] : A'=0, B'=0, C'=free_1, [ A+B>=1 && A>=1 && B>=1 ], cost: 1+B
     25: f2 -> [3] : [ A+B>=1 && A>=1 && B>=1 ], cost: INF
     26: f2 -> [3] : A'=0, B'=0, C'=free, [ A+B>=1 && A>=1 && B>=1 ], cost: 1+B
     27: f2 -> [3] : A'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), B'=1/2+(-1)^(-1+B)*B-1/2*(-1)^(-1+B), C'=free, [ -1+B==0 && A>=1 && A+B>=1 ], cost: 1/2+(-1)^B*B+1/2*(-1)^(-1+B)+B


Computing complexity for remaining 5 transitions.

Found new complexity INF, because: INF sat.


The final runtime is determined by this resulting transition:
  Final Guard: A+B>=1 && B>=1 && A>=1
  Final Cost:  INF

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: INF
  Complexity value: INF

WORST_CASE(INF,?)
