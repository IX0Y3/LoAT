Trying to load file: aaron2.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=1+A && B==C && D==E && F==A ], cost: 1
      1: start -> stop : [ A>=0 && C>=1+E && B==C && D==E && F==A ], cost: 1
      2: start -> lbl91 : D'=-1+D-F, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      3: start -> lbl101 : B'=1+F+B, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      4: lbl91 -> stop : [ B>=1+D && B>=C && A>=0 && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
      5: lbl91 -> stop : [ D>=B && 0>=1+A && B>=C && A>=0 && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
      6: lbl91 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
      7: lbl91 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
      8: lbl101 -> stop : [ B>=1+D && E>=D && A>=0 && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
      9: lbl101 -> stop : [ D>=B && 0>=1+A && E>=D && A>=0 && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     10: lbl101 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     11: lbl101 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     12: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1


Simplified the transitions:
  Start location: start0
      2: start -> lbl91 : D'=-1+D-F, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      3: start -> lbl101 : B'=1+F+B, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      6: lbl91 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
      7: lbl91 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     10: lbl101 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     11: lbl101 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     12: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1


Try instantiation
  Start location: start0
      2: start -> lbl91 : D'=-1+D-F, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      3: start -> lbl101 : B'=1+F+B, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
     13: lbl91 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
      7: lbl91 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     10: lbl101 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     11: lbl101 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     12: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1

Eliminating 1 self-loops for location lbl91
  Removing the self-loops: 13.
Adding an epsilon transition (to model nonexecution of the loops): 15.

Try instantiation
  Start location: start0
      2: start -> lbl91 : D'=-1+D-F, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      3: start -> lbl101 : B'=1+F+B, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
     14: lbl91 -> [5] : D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     15: lbl91 -> [5] : [], cost: 0
     10: lbl101 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     16: lbl101 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     12: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1
      7: [5] -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1

Eliminating 1 self-loops for location lbl101
  Removing the self-loops: 16.
Adding an epsilon transition (to model nonexecution of the loops): 18.

Removed all Self-loops using metering functions (where possible):
  Start location: start0
      2: start -> lbl91 : D'=-1+D-F, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
      3: start -> lbl101 : B'=1+F+B, [ A>=0 && E>=C && B==C && D==E && F==A ], cost: 1
     14: lbl91 -> [5] : D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     15: lbl91 -> [5] : [], cost: 0
     17: lbl101 -> [6] : B'=1+F+B, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     18: lbl101 -> [6] : [], cost: 0
     12: start0 -> start : B'=C, D'=E, F'=A, [], cost: 1
      7: [5] -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     10: [6] -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1


Applied chaining over branches and pruning:
  Start location: start0
     21: lbl91 -> lbl101 : B'=1+F+B, D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A && A>=0 && -1+D-F>=B && B>=C && D-F+A>=B && E>=D-F+A && F==A ], cost: 2
     22: lbl91 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     23: lbl101 -> lbl91 : B'=1+F+B, D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A && A>=0 && D>=1+F+B && E>=D && 1+F+B>=1+C+A && 1+D+A>=1+F+B && F==A ], cost: 2
     24: lbl101 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     19: start0 -> lbl91 : B'=C, D'=-1+E-A, F'=A, [ A>=0 && E>=C && C==C && E==E && A==A ], cost: 2
     20: start0 -> lbl101 : B'=1+C+A, D'=E, F'=A, [ A>=0 && E>=C && C==C && E==E && A==A ], cost: 2


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
     21: lbl91 -> lbl101 : B'=1+F+B, D'=-1+D-F, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A && A>=0 && -1+D-F>=B && B>=C && D-F+A>=B && E>=D-F+A && F==A ], cost: 2
     22: lbl91 -> lbl101 : B'=1+F+B, [ A>=0 && D>=B && B>=C && 1+D+A>=B && E>=1+D+A && F==A ], cost: 1
     23: lbl101 -> lbl91 : B'=1+F+B, D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A && A>=0 && D>=1+F+B && E>=D && 1+F+B>=1+C+A && 1+D+A>=1+F+B && F==A ], cost: 2
     24: lbl101 -> lbl91 : D'=-1+D-F, [ A>=0 && D>=B && E>=D && B>=1+C+A && 1+D+A>=B && F==A ], cost: 1
     19: start0 -> lbl91 : B'=C, D'=-1+E-A, F'=A, [ A>=0 && E>=C && C==C && E==E && A==A ], cost: 2
     20: start0 -> lbl101 : B'=1+C+A, D'=E, F'=A, [ A>=0 && E>=C && C==C && E==E && A==A ], cost: 2

This is only a partial result (probably due to a timeout), trying to find max complexity

Removed transitions with const cost
  Start location: start0
    <empty>


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
