Trying to load file: speedpldi2.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=A && B==C && D==E && F==G && H==A ], cost: 1
      1: start -> stop : [ 0>=1+G && B==C && D==E && F==G && H==A ], cost: 1
      2: start -> stop : B'=0, D'=F, [ A>=1 && F==0 && B==C && D==E && G==0 && H==A ], cost: 1
      3: start -> lM1 : B'=1, D'=-1+F, [ A>=1 && G>=1 && B==C && D==E && F==G && H==A ], cost: 1
      4: lM1 -> stop : [ A>=B && G>=B && B>=1 && D==0 && H==A && F==G ], cost: 1
      6: lM1 -> lM1 : B'=1+B, D'=-1+D, [ A>=1+B && D>=1 && A>=B && G>=D+B && B>=1 && D>=0 && H==A && F==G ], cost: 1
      5: lM1 -> lZZ1 : B'=0, [ D>=1 && G>=D+A && A>=1 && D>=0 && B==A && H==A && F==G ], cost: 1
      7: lZZ1 -> stop : [ 0>=D && G>=D+A && A>=2 && D>=1 && B==0 && H==A && F==G ], cost: 1
      9: lZZ1 -> lM1 : B'=1+B, D'=-1+D, [ A>=1 && D>=1 && G>=D+A && A>=2 && B==0 && H==A && F==G ], cost: 1
      8: lZZ1 -> lZZ1 : B'=0, [ D>=1 && 0>=A && G>=D+A && A>=2 && B==0 && H==A && F==G ], cost: 1
     10: start0 -> start : B'=C, D'=E, F'=G, H'=A, [], cost: 1


Simplified the transitions:
  Start location: start0
      3: start -> lM1 : B'=1, D'=-1+F, [ A>=1 && G>=1 && B==C && D==E && F==G && H==A ], cost: 1
      6: lM1 -> lM1 : B'=1+B, D'=-1+D, [ A>=1+B && D>=1 && G>=D+B && B>=1 && H==A && F==G ], cost: 1
      5: lM1 -> lZZ1 : B'=0, [ D>=1 && G>=D+A && A>=1 && B==A && H==A && F==G ], cost: 1
      9: lZZ1 -> lM1 : B'=1+B, D'=-1+D, [ D>=1 && G>=D+A && A>=2 && B==0 && H==A && F==G ], cost: 1
      8: lZZ1 -> lZZ1 : B'=0, [ D>=1 && 0>=A && G>=D+A && A>=2 && B==0 && H==A ], cost: 1
     10: start0 -> start : B'=C, D'=E, F'=G, H'=A, [], cost: 1

Eliminating 1 self-loops for location lM1
  Removing the self-loops: 6 11 12.
Eliminating 1 self-loops for location lZZ1
  Self-Loop 8 has unbounded runtime, resulting in the new transition 14.
  Removing the self-loops: 8.

Accelerated all simple loops using metering functions (where possible):
  Start location: start0
      3: start -> lM1 : B'=1, D'=-1+F, [ A>=1 && G>=1 && B==C && D==E && F==G && H==A ], cost: 1
     13: lM1 -> lM1 : B'=1+B, D'=-1+D, [ A>=1+B && D>=1 && G>=D+B && B>=1 && H==A && F==G ], cost: 1
      5: lM1 -> lZZ1 : B'=0, [ D>=1 && G>=D+A && A>=1 && B==A && H==A && F==G ], cost: 1
      9: lZZ1 -> lM1 : B'=1+B, D'=-1+D, [ D>=1 && G>=D+A && A>=2 && B==0 && H==A && F==G ], cost: 1
     14: lZZ1 -> lZZ1 : [ D>=1 && 0>=A && G>=D+A && A>=2 && B==0 && H==A ], cost: INF
     10: start0 -> start : B'=C, D'=E, F'=G, H'=A, [], cost: 1


Chained simpled loops:
  Start location: start0
      3: start -> lM1 : B'=1, D'=-1+F, [ A>=1 && G>=1 && B==C && D==E && F==G && H==A ], cost: 1
     15: start -> lM1 : B'=2, D'=-2+F, [ A>=1 && G>=1 && B==C && D==E && F==G && H==A && A>=2 && -1+F>=1 && G>=F && 1>=1 && H==A && F==G ], cost: 2
      5: lM1 -> lZZ1 : B'=0, [ D>=1 && G>=D+A && A>=1 && B==A && H==A && F==G ], cost: 1
      9: lZZ1 -> lM1 : B'=1+B, D'=-1+D, [ D>=1 && G>=D+A && A>=2 && B==0 && H==A && F==G ], cost: 1
     16: lZZ1 -> lM1 : B'=2+B, D'=-2+D, [ D>=1 && G>=D+A && A>=2 && B==0 && H==A && F==G && A>=2+B && -1+D>=1 && G>=D+B && 1+B>=1 && H==A && F==G ], cost: 2
     10: start0 -> start : B'=C, D'=E, F'=G, H'=A, [], cost: 1


Eliminated locations (branches):
  Start location: start0
     19: lM1 -> lM1 : B'=1, D'=-1+D, [ D>=1 && G>=D+A && A>=1 && B==A && H==A && F==G && D>=1 && G>=D+A && A>=2 && 0==0 && H==A && F==G ], cost: 2
     20: lM1 -> lM1 : B'=2, D'=-2+D, [ D>=1 && G>=D+A && A>=1 && B==A && H==A && F==G && D>=1 && G>=D+A && A>=2 && 0==0 && H==A && F==G && A>=2 && -1+D>=1 && G>=D && 1>=1 && H==A && F==G ], cost: 3
     17: start0 -> lM1 : B'=1, D'=-1+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A ], cost: 2
     18: start0 -> lM1 : B'=2, D'=-2+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A && A>=2 && -1+G>=1 && G>=G && 1>=1 && A==A && G==G ], cost: 3

Eliminating 2 self-loops for location lM1
  Removing the self-loops: 19 20.

Accelerated all simple loops using metering functions (where possible):
  Start location: start0
     21: lM1 -> lM1 : B'=1, D'=-1+D, [ D>=1 && G>=D+A && B==A && H==A && F==G && A>=2 ], cost: 2
     22: lM1 -> lM1 : B'=2, D'=-2+D, [ G>=D+A && B==A && H==A && F==G && A>=2 && -1+D>=1 && G>=D ], cost: 3
     17: start0 -> lM1 : B'=1, D'=-1+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A ], cost: 2
     18: start0 -> lM1 : B'=2, D'=-2+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A && A>=2 && -1+G>=1 && G>=G && 1>=1 && A==A && G==G ], cost: 3


Chained simpled loops:
  Start location: start0
     17: start0 -> lM1 : B'=1, D'=-1+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A ], cost: 2
     18: start0 -> lM1 : B'=2, D'=-2+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A && A>=2 && -1+G>=1 && G>=G && 1>=1 && A==A && G==G ], cost: 3
     23: start0 -> lM1 : B'=1, D'=-3+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A && A>=2 && -1+G>=1 && G>=G && 1>=1 && A==A && G==G && -2+G>=1 && G>=-2+G+A && 2==A && A==A && G==G && A>=2 ], cost: 5
     24: start0 -> lM1 : B'=2, D'=-4+G, F'=G, H'=A, [ A>=1 && G>=1 && C==C && E==E && G==G && A==A && A>=2 && -1+G>=1 && G>=G && 1>=1 && A==A && G==G && G>=-2+G+A && 2==A && A==A && G==G && A>=2 && -3+G>=1 && G>=-2+G ], cost: 6


Pruned:
  Start location: start0
    <empty>


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
    <empty>


Computing complexity for remaining 0 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
