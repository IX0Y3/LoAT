Trying to load file: speedpldi4.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=A && B==C && D==A && E==F ], cost: 1
      1: start -> lbl6 : [ A>=1 && A>=C && B==C && D==A && E==F ], cost: 1
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
      3: lbl6 -> stop : [ A>=1 && A>=C && E==F && D==A && B==C ], cost: 1
      9: lbl121 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+A && A>=1 && E>=0 && C>=E+A && D==A && B==C ], cost: 1
      8: lbl121 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && E>=0 && C>=E+A && D==A && B==C ], cost: 1
      7: lbl121 -> cut : [ C>=1+A && A>=1 && C>=A && E==0 && D==A && B==C ], cost: 1
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && E>=0 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
      5: lbl111 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && E>=0 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
      4: lbl111 -> cut : [ C>=1+A && A>=2 && E==0 && D==A && B==C ], cost: 1
     10: cut -> stop : [ A>=1 && C>=1+A && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1


Simplified the transitions:
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
      9: lbl121 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      8: lbl121 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
      5: lbl111 -> lbl111 : E'=-1+E, [ E>=1 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1


Try instantiation
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
     12: lbl121 -> lbl121 : E'=-1+A, [ E>=A && C>=E+A && 1<=A && B<=C && D<=1 && 1>=A && B>=C && D>=1 ], cost: 1+E-A
      8: lbl121 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
      5: lbl111 -> lbl111 : E'=-1+E, [ E>=1 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1

Eliminating 1 self-loops for location lbl121
  Self-Loop 12 has the metering function: 1-A, resulting in the new transition 13.
  Removing the self-loops: 12.

Try instantiation
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
     13: lbl121 -> [7] : E'=-1+A, [ E>=A && C>=E+A && 1-A==0 && B-C==0 && -1+D==0 ], cost: 0
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
     14: lbl111 -> lbl111 : E'=0, [ E>=1 && C>=1+E+A && A>=2+E && D<=A && B<=C && D>=A && B>=C ], cost: E
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1
      8: [7] -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1

Eliminating 1 self-loops for location lbl111
  Removing the self-loops: 14.
Adding an epsilon transition (to model nonexecution of the loops): 16.

Removed all Self-loops using metering functions (where possible):
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
     13: lbl121 -> [7] : E'=-1+A, [ E>=A && C>=E+A && 1-A==0 && B-C==0 && -1+D==0 ], cost: 0
     15: lbl111 -> [8] : E'=0, [ E>=1 && C>=1+E+A && A>=2+E && D-A==0 && B-C==0 ], cost: E
     16: lbl111 -> [8] : [], cost: 0
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1
      8: [7] -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      6: [8] -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1


Applied simple chaining:
  Start location: start0
     13: lbl121 -> [7] : E'=-1+A, [ E>=A && C>=E+A && 1-A==0 && B-C==0 && -1+D==0 ], cost: 0
     15: lbl111 -> [8] : E'=0, [ E>=1 && C>=1+E+A && A>=2+E && D-A==0 && B-C==0 ], cost: E
     16: lbl111 -> [8] : [], cost: 0
     11: start0 -> lbl121 : B'=C, D'=A, E'=-A+C, [ A>=1 && C>=1+A && C==C && A==A && F==F ], cost: 2
      8: [7] -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      6: [8] -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1


Applied chaining over branches and pruning:
  Start location: start0
    <empty>


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
    <empty>


Computing complexity for remaining 0 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
