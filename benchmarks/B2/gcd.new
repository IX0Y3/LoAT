Trying to load file: gcd.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=A && B==C && D==A ], cost: 1
      1: start -> lbl6 : [ A>=1 && 0>=C && B==C && D==A ], cost: 1
      2: start -> cut : [ A>=1 && D==A && B==A && C==A ], cost: 1
      3: start -> lbl101 : B'=-D+B, [ A>=1 && C>=1+A && B==C && D==A ], cost: 1
      4: start -> lbl111 : D'=D-B, [ A>=1+C && C>=1 && B==C && D==A ], cost: 1
      5: lbl6 -> stop : [ A>=1 && 0>=C && D==A && B==C ], cost: 1
     12: cut -> stop : [ A>=B && B>=1 && C>=B && D==B ], cost: 1
      6: lbl101 -> cut : [ A>=B && B>=1 && C>=2*B && D==B ], cost: 1
      7: lbl101 -> lbl101 : B'=-D+B, [ B>=1+D && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
      8: lbl101 -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
      9: lbl111 -> cut : [ C>=B && B>=1 && A>=2*B && D==B ], cost: 1
     10: lbl111 -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     11: lbl111 -> lbl111 : D'=D-B, [ D>=1+B && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     13: start0 -> start : B'=C, D'=A, [], cost: 1


Simplified the transitions:
  Start location: start0
      3: start -> lbl101 : B'=-D+B, [ A>=1 && C>=1+A && B==C && D==A ], cost: 1
      4: start -> lbl111 : D'=D-B, [ A>=1+C && C>=1 && B==C && D==A ], cost: 1
      7: lbl101 -> lbl101 : B'=-D+B, [ B>=1+D && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
      8: lbl101 -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
     10: lbl111 -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     11: lbl111 -> lbl111 : D'=D-B, [ D>=1+B && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     13: start0 -> start : B'=C, D'=A, [], cost: 1


Try instantiation
  Start location: start0
      3: start -> lbl101 : B'=-D+B, [ A>=1 && C>=1+A && B==C && D==A ], cost: 1
      4: start -> lbl111 : D'=D-B, [ A>=1+C && C>=1 && B==C && D==A ], cost: 1
     14: lbl101 -> lbl101 : B'=1, [ B>=2 && C>=1+B && A>=1 && D<=1 && D>=1 ], cost: -1+B
      8: lbl101 -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
     10: lbl111 -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     11: lbl111 -> lbl111 : D'=D-B, [ D>=1+B && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     13: start0 -> start : B'=C, D'=A, [], cost: 1

Eliminating 1 self-loops for location lbl101
  Removing the self-loops: 14.
Adding an epsilon transition (to model nonexecution of the loops): 16.

Try instantiation
  Start location: start0
      3: start -> lbl101 : B'=-D+B, [ A>=1 && C>=1+A && B==C && D==A ], cost: 1
      4: start -> lbl111 : D'=D-B, [ A>=1+C && C>=1 && B==C && D==A ], cost: 1
     15: lbl101 -> [7] : B'=1, [ B>=2 && C>=1+B && A>=1 && -1+D==0 ], cost: -1+B
     16: lbl101 -> [7] : [], cost: 0
     10: lbl111 -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     17: lbl111 -> lbl111 : D'=1, [ D>=2 && A>=1+D && C>=1 && B<=1 && B>=1 ], cost: -1+D
     13: start0 -> start : B'=C, D'=A, [], cost: 1
      8: [7] -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1

Eliminating 1 self-loops for location lbl111
  Removing the self-loops: 17.
Adding an epsilon transition (to model nonexecution of the loops): 19.

Removed all Self-loops using metering functions (where possible):
  Start location: start0
      3: start -> lbl101 : B'=-D+B, [ A>=1 && C>=1+A && B==C && D==A ], cost: 1
      4: start -> lbl111 : D'=D-B, [ A>=1+C && C>=1 && B==C && D==A ], cost: 1
     15: lbl101 -> [7] : B'=1, [ B>=2 && C>=1+B && A>=1 && -1+D==0 ], cost: -1+B
     16: lbl101 -> [7] : [], cost: 0
     18: lbl111 -> [8] : D'=1, [ D>=2 && A>=1+D && C>=1 && -1+B==0 ], cost: -1+D
     19: lbl111 -> [8] : [], cost: 0
     13: start0 -> start : B'=C, D'=A, [], cost: 1
      8: [7] -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
     10: [8] -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1


Applied chaining over branches and pruning:
  Start location: start0
     23: lbl101 -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
     22: lbl101 -> [9] : B'=1, [ B>=2 && C>=1+B && A>=1 && -1+D==0 ], cost: -1+B
     25: lbl111 -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     24: lbl111 -> [10] : D'=1, [ D>=2 && A>=1+D && C>=1 && -1+B==0 ], cost: -1+D
     20: start0 -> lbl101 : B'=-A+C, D'=A, [ A>=1 && C>=1+A && C==C && A==A ], cost: 2
     21: start0 -> lbl111 : B'=C, D'=A-C, [ A>=1+C && C>=1 && C==C && A==A ], cost: 2


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
     23: lbl101 -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
     22: lbl101 -> [9] : B'=1, [ B>=2 && C>=1+B && A>=1 && -1+D==0 ], cost: -1+B
     25: lbl111 -> lbl101 : B'=-D+B, [ B>=1+D && C>=B && B>=1 && D>=1 && A>=D+B ], cost: 1
     24: lbl111 -> [10] : D'=1, [ D>=2 && A>=1+D && C>=1 && -1+B==0 ], cost: -1+D
     20: start0 -> lbl101 : B'=-A+C, D'=A, [ A>=1 && C>=1+A && C==C && A==A ], cost: 2
     21: start0 -> lbl111 : B'=C, D'=A-C, [ A>=1+C && C>=1 && C==C && A==A ], cost: 2

This is only a partial result (probably due to a timeout), trying to find max complexity

Removed transitions with const cost
  Start location: start0
     23: lbl101 -> lbl111 : D'=D-B, [ D>=1+B && A>=D && B>=1 && D>=1 && C>=D+B ], cost: 1
     22: lbl101 -> [9] : B'=1, [ B>=2 && C>=1+B && A>=1 && -1+D==0 ], cost: -1+B
     24: lbl111 -> [10] : D'=1, [ D>=2 && A>=1+D && C>=1 && -1+B==0 ], cost: -1+D
     20: start0 -> lbl101 : B'=-A+C, D'=A, [ A>=1 && C>=1+A && C==C && A==A ], cost: 2

Performed chaining from the start location:
  Start location: start0
     24: lbl111 -> [10] : D'=1, [ D>=2 && A>=1+D && C>=1 && -1+B==0 ], cost: -1+D
     26: start0 -> lbl111 : B'=-A+C, D'=2*A-C, [ A>=1 && C>=1+A && C==C && A==A && A>=1-A+C && A>=A && -A+C>=1 && A>=1 && C>=C ], cost: 3
     27: start0 -> [9] : B'=1, D'=A, [ A>=1 && C>=1+A && C==C && A==A && -A+C>=2 && C>=1-A+C && A>=1 && -1+A==0 ], cost: 1-A+C

  Found configuration with infinitely models for cost: 1-A+C
  and guard: A>=1 && C>=1+A && C==C && A==A && -A+C>=2 && C>=1-A+C && A>=1 && -1+A==0:
  A: Both, C: Pos

Found new complexity n^1, because: Found infinity configuration.

Performed chaining from the start location:
  Start location: start0
     28: start0 -> [10] : B'=-A+C, D'=1, [ A>=1 && C>=1+A && C==C && A==A && A>=1-A+C && A>=A && -A+C>=1 && A>=1 && C>=C && 2*A-C>=2 && A>=1+2*A-C && C>=1 && -1-A+C==0 ], cost: 2+2*A-C

Performed chaining from the start location:
  Start location: start0
    <empty>


The final runtime is determined by this resulting transition:
  Final Guard: A>=1 && C>=1+A && C==C && A==A && -A+C>=2 && C>=1-A+C && A>=1 && -1+A==0
  Final Cost:  1-A+C

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: n^1
  Complexity value: 1

WORST_CASE(Omega(n^1),?)
