Trying to load file: speedpldi4.koat

Initial Control flow graph problem:
  Start location: start0
      0: start -> stop : [ 0>=A && B==C && D==A && E==F ], cost: 1
      1: start -> lbl6 : [ A>=1 && A>=C && B==C && D==A && E==F ], cost: 1
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
      3: lbl6 -> stop : [ A>=1 && A>=C && E==F && D==A && B==C ], cost: 1
      9: lbl121 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+A && A>=1 && E>=0 && C>=E+A && D==A && B==C ], cost: 1
      8: lbl121 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && E>=0 && C>=E+A && D==A && B==C ], cost: 1
      7: lbl121 -> cut : [ C>=1+A && A>=1 && C>=A && E==0 && D==A && B==C ], cost: 1
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && E>=0 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
      5: lbl111 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && E>=0 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
      4: lbl111 -> cut : [ C>=1+A && A>=2 && E==0 && D==A && B==C ], cost: 1
     10: cut -> stop : [ A>=1 && C>=1+A && E==0 && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1


Simplified the transitions:
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
      9: lbl121 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      8: lbl121 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A ], cost: 1
      5: lbl111 -> lbl111 : E'=-1+E, [ E>=1 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1

Eliminating 1 self-loops for location lbl121
  Removing the self-loops: 9.
Eliminating 1 self-loops for location lbl111
  Self-Loop 5 has the metering function: E, resulting in the new transition 13.
  Removing the self-loops: 5.

Accelerated all simple loops using metering functions (where possible):
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
     12: lbl121 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      8: lbl121 -> lbl111 : E'=-1+E, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C ], cost: 1
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A ], cost: 1
     13: lbl111 -> lbl111 : E'=0, [ E>=1 && C>=1+E+A && A>=2+E && D==A && B==C ], cost: E
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1


Chained simpled loops:
  Start location: start0
      2: start -> lbl121 : E'=-D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F ], cost: 1
     14: start -> lbl121 : E'=-2*D+B, [ A>=1 && C>=1+A && B==C && D==A && E==F && -D+B>=1 && -D+B>=A && C>=1+A && A>=1 && C>=-D+B+A && D==A && B==C ], cost: 2
     15: lbl121 -> lbl111 : E'=0, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C && -1+E>=1 && C>=E+A && A>=1+E && D==A && B==C ], cost: E
      6: lbl111 -> lbl121 : E'=-D+E, [ E>=1 && E>=A && C>=1+E+A && A>=2+E && D==A ], cost: 1
     11: start0 -> start : B'=C, D'=A, E'=F, [], cost: 1


Eliminated locations (branches):
  Start location: start0
     18: lbl121 -> [7] : E'=0, [ E>=1 && A>=1+E && C>=1+A && A>=1 && C>=E+A && D==A && B==C && -1+E>=1 && C>=E+A && A>=1+E && D==A && B==C ], cost: E
     16: start0 -> lbl121 : B'=C, D'=A, E'=C-A, [ A>=1 && C>=1+A && C==C && A==A && F==F ], cost: 2
     17: start0 -> lbl121 : B'=C, D'=A, E'=C-2*A, [ A>=1 && C>=1+A && C==C && A==A && F==F && C-A>=1 && C-A>=A && C>=1+A && A>=1 && C>=C && A==A && C==C ], cost: 3


Eliminated locations (branches):
  Start location: start0
     19: start0 -> [7] : B'=C, D'=A, E'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && C-A>=1 && A>=1+C-A && C>=1+A && A>=1 && C>=C && A==A && C==C && -1+C-A>=1 && C>=C && A>=1+C-A && A==A && C==C ], cost: 2+C-A
     20: start0 -> [7] : B'=C, D'=A, E'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && C-A>=1 && C-A>=A && C>=1+A && A>=1 && C>=C && A==A && C==C && C-2*A>=1 && A>=1+C-2*A && C>=1+A && A>=1 && C>=C-A && A==A && C==C && -1+C-2*A>=1 && C>=C-A && A>=1+C-2*A && A==A && C==C ], cost: 3+C-2*A


Final control flow graph problem, now checking costs for infinitely many models:
  Start location: start0
     19: start0 -> [7] : B'=C, D'=A, E'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && C-A>=1 && A>=1+C-A && C>=1+A && A>=1 && C>=C && A==A && C==C && -1+C-A>=1 && C>=C && A>=1+C-A && A==A && C==C ], cost: 2+C-A
     20: start0 -> [7] : B'=C, D'=A, E'=0, [ A>=1 && C>=1+A && C==C && A==A && F==F && C-A>=1 && C-A>=A && C>=1+A && A>=1 && C>=C && A==A && C==C && C-2*A>=1 && A>=1+C-2*A && C>=1+A && A>=1 && C>=C-A && A==A && C==C && -1+C-2*A>=1 && C>=C-A && A>=1+C-2*A && A==A && C==C ], cost: 3+C-2*A


Computing complexity for remaining 2 transitions.


The final runtime is determined by this resulting transition:
  Final Guard: 
  Final Cost:  1

Obtained the following complexity w.r.t. the length of the input n:
  Complexity class: const
  Complexity value: 0

WORST_CASE(Omega(1),?)
